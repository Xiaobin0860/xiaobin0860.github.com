<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>https://xiaobin0860.github.io/</link>
    <atom:link href="https://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 15 Aug 2021 10:00:49 +0000</pubDate>
    <lastBuildDate>Sun, 15 Aug 2021 10:00:49 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>AI数学基础-最优化理论</title>
        <description>&lt;p&gt;人工智能的目标是最优化：在复杂环境和多体交互中做出最优决策。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;最优化理论&lt;/code&gt;研究的问题是给定的&lt;code&gt;目标函数&lt;/code&gt;的最大值（最小值）是否存在，并找到令目标函数取到最大值（最小值）的数值。
如果把给定的目标函数看成连绵的山脉，最优化的过程就是判断顶峰的位置并找到到达顶峰路径的过程。
大多数最优化问题都可以通过使目标函数$f(x)$最小化解决，最大化问题则可以通过最小化$−f(x)$实现。
在人工智能和深度学习的应用场景下，只要目标函数的取值足够小，就可以把这个值当作全局最小值使用，作为对性能和复杂度的折中。&lt;/p&gt;

&lt;p&gt;根据约束条件的不同，最优化问题可以分为&lt;code&gt;无约束优化&lt;/code&gt;和&lt;code&gt;约束优化&lt;/code&gt;两类。无约束优化对自变量 x 的取值没有限制，约束优化则把 x 的取值限制在特定的集合内，也就是满足一定的约束条件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;线性规划&lt;/code&gt;就是一类典型的约束优化，其解决的问题通常是在有限的成本约束下取得最大的收益。约束优化问题通常比无约束优化问题更加复杂，但通过拉格朗日乘子的引入可以将含有$n$个变量和$k$个约束条件的问题转化为含有$(n+k)$个变量的无约束优化问题。&lt;/p&gt;

&lt;p&gt;求解无约束优化问题最常用的方法是&lt;code&gt;梯度下降法&lt;/code&gt;。直观地说，梯度下降法就是沿着目标函数值下降最快的方向寻找最小值，就像爬山时要沿着坡度最陡的路径寻找山顶一样。在数学上，梯度的方向是目标函数导数的反方向。&lt;/p&gt;

&lt;p&gt;如果将二阶导数引入优化过程，得到的典型方法就是牛顿法。在牛顿法中，目标函数首先被泰勒展开，写成二阶近似的形式（相比之下，梯度下降法只保留了目标函数的一阶近似）。此时再对二阶近似后的目标函数求导，并令其导数等于 0，得到的向量表示的就是下降最快的方向。相比于梯度下降法，牛顿法的收敛速度更快。&lt;/p&gt;

&lt;p&gt;不管是利用一阶导数的梯度下降法，还是利用二阶导数的牛顿法，其寻找最小值点的基本思想都是先确定方向，再确定步长，因而统称为&lt;code&gt;线性搜索方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有一类算法，其寻找最小值点的基本思路是先确定步长，以步长为参数划定一个区域，再在这个区域内寻找最快下降的方向。这类算法被称为&lt;code&gt;置信域方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;相对于传统的基于数学理论的最优化方法，启发式算法显得返璞归真。启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。&lt;/p&gt;

&lt;p&gt;启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。事实上，搜索越多并不意味着智能越高，智能高的表现恰恰是能够善用启发式策略，不用经过大量搜索也能解决问题。启发式算法的实例包括模拟生物进化规律的遗传算法、模拟统计物理中固体结晶过程的模拟退火算法、模拟低等动物产生集群智能的蚁群算法等。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210814.jpg&quot; alt=&quot;宝贝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>最优化理论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-数理统计</title>
        <description>&lt;p&gt;&lt;code&gt;数理统计&lt;/code&gt;根据实验或观察得到的数据来研究随机现象，并对研究对象的客观规律做出合理的估计和判断。&lt;/p&gt;

&lt;p&gt;在数理统计中，可用的资源是有限的数据集合，这个有限的数据集合称为&lt;code&gt;样本&lt;/code&gt;。
相应的，观察对象的所有取值被称为&lt;code&gt;总体&lt;/code&gt;。数理统计的任务就是
根据样本推断总体的数字特征。&lt;/p&gt;

&lt;p&gt;推断的工具是统计量，统计量是样本的函数，是个随机变量。两个最重要的统计量是&lt;code&gt;样本均值&lt;/code&gt;和&lt;code&gt;样本方差&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样本均值：$\overline{X} = \frac{1}{n}\sum_{i=1}^nX_i$&lt;/li&gt;
  &lt;li&gt;样本方差：$S^2 = \frac{1}{n-1}\sum_{i=1}^n(X_i-\overline{X})^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;统计推断的基本问题分为两大类：&lt;code&gt;参数估计&lt;/code&gt;和&lt;code&gt;假设检验&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数估计通过随机抽取样本来估计部分分布的未知参数，包括点估计和区间估计&lt;/p&gt;

&lt;p&gt;假设检验通过随机抽取样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210813.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1</guid>
        
        
        <category>AI</category>
        
        <category>数理统计</category>
        
      </item>
    
      <item>
        <title>AI数学基础-概率论</title>
        <description>&lt;p&gt;同线性代数一样，概率论也代表了一种看待世界的方式，&lt;code&gt;其关注的焦点是无处不在的可能性&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;频率学派&quot;&gt;频率学派&lt;/h2&gt;

&lt;p&gt;从事件发生的频率认识概率的方法被称为“频率学派”（frequentist probability），“概率”，其实是一个可独立重复的随机实验中单个结果出现频率的极限。在概率的定量计算上，频率学派依赖的基础是古典概率模型。假设所有基本事件的数目为 n，待观察的随机事件 A 中包含的基本事件数目为 k，则古典概率模型下事件概率的计算公式为&lt;/p&gt;

&lt;p&gt;$P(A) = \frac{k}{n}$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;条件概率&lt;/code&gt;是根据已有信息对样本空间进行调整后得到的新的概率分布。假定有两个随机事件 A 和 B，条件概率就是指事件 A 在事件 B 已经发生的条件下发生的概率，用以下公式表示&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A&lt;/td&gt;
      &lt;td&gt;B) = \frac{P(AB)}{P(B)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(AB)$称为&lt;code&gt;联合概率&lt;/code&gt;，表示的是 A 和 B 两个事件共同发生的概率。如果联合概率等于两个事件各自概率的乘积，即$P(AB) = P(A)*P(B)$，说明这两个事件的发生互不影响，即两者相互独立。&lt;/p&gt;

&lt;p&gt;基于条件概率可以得出&lt;code&gt;全概率公式&lt;/code&gt;。全概率公式的作用在于将复杂事件的概率求解转化为在不同情况下发生的简单事件的概率求和，即&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A) = \sum_{i=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$\sum_{i=1}^NP(B_i) = 1$&lt;/p&gt;

&lt;p&gt;全概率公式代表了频率学派解决概率问题的思路，即先做出一些假设$P(B_i​)$，再在这些假设下讨论随机事件的概率$P(A∣B_i​)$。&lt;/p&gt;

&lt;h2 id=&quot;贝叶斯学派&quot;&gt;贝叶斯学派&lt;/h2&gt;

&lt;p&gt;对全概率公式稍作整理，就演化出了求解“逆概率”这一重要问题。所谓“逆概率”解决的是在事件结果已经确定的条件下$P(A)$，推断各种假设发生的可能性$P(B_i​∣A)$。其通用的公式形式被称为贝叶斯公式：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(B_i&lt;/td&gt;
      &lt;td&gt;A) = \frac{P(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)}{\sum_{j=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_j)*P(B_j)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;贝叶斯公式可以进一步抽象为贝叶斯定理：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(H&lt;/td&gt;
      &lt;td&gt;D) = \frac{P(D&lt;/td&gt;
      &lt;td&gt;H)*P(H)}{P(D)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(H)$被称为&lt;code&gt;先验概率&lt;/code&gt;，即预先设定的假设成立的概率；$P(D∣H)$被称为&lt;code&gt;似然概率&lt;/code&gt;，是在假设成立的前提下观测到结果的概率；$P(H∣D)$被称为&lt;code&gt;后验概率&lt;/code&gt;，即在观测到结果的前提下假设成立的概率。&lt;/p&gt;

&lt;p&gt;贝叶斯定理提供了一种全新的逻辑。它根据观测结果寻找合理的假设，或者说根据观测数据寻找最佳的理论解释，其关注的焦点在于后验概率。概率论的&lt;code&gt;贝叶斯学派&lt;/code&gt;正是诞生于这种理念。&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;p&gt;频率学派认为假设是客观存在且不会改变的，即存在固定的先验分布，只是作为观察者的我们无从知晓。因而在计算具体事件的概率时，要先确定概率分布的类型和参数，以此为基础进行概率推演。相比之下，贝叶斯学派则认为固定的先验分布是不存在的，参数本身也是随机数。换言之，假设本身取决于观察结果，是不确定并且可以修正的。数据的作用就是对假设做出不断的修正，使观察者对概率的主观认识更加接近客观实际。&lt;/p&gt;

&lt;p&gt;概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。&lt;/p&gt;

&lt;p&gt;概率的估计有两种方法：&lt;code&gt;最大似然估计法&lt;/code&gt;和&lt;code&gt;最大后验概率法&lt;/code&gt;，两者分别体现出频率学派和贝叶斯学派对概率的理解方式。最大似然估计法的思想是使训练数据出现的概率最大化，依此确定概率分布中的未知参数，估计出的概率分布也就最符合训练数据的分布。最大后验概率法的思想则是根据训练数据和已知的其他条件，使未知参数出现的可能性最大化，并选取最可能的未知参数取值作为估计值。在估计参数时，最大似然估计法只需要使用训练数据，最大后验概率法除了数据外还需要额外的信息，就是贝叶斯公式中的先验概率。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;概率论关注的是生活中的不确定性或可能性&lt;/li&gt;
  &lt;li&gt;频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算&lt;/li&gt;
  &lt;li&gt;贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210809.jpg&quot; alt=&quot;M&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>概率论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(2)</title>
        <description>&lt;h2 id=&quot;线性空间&quot;&gt;线性空间&lt;/h2&gt;

&lt;p&gt;一个集合，它的元素是具有相同维数的向量，并且定义了加法和数乘结构化运算，这样的集合就被称为&lt;code&gt;线性空间&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;内积空间&quot;&gt;内积空间&lt;/h2&gt;

&lt;p&gt;定义了内积运算的线性空间被称为&lt;code&gt;内积空间&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;内积空间中，一组两两正交的向量构成这个空间的&lt;code&gt;正交基&lt;/code&gt;，若正交基中基向量的$L^2$范数都是单位长度 1，这组正交基就是&lt;code&gt;标准正交基&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;矩阵&quot;&gt;矩阵&lt;/h2&gt;

&lt;p&gt;线性空间点的变化对应着向量的线性变换，而描述对象变化抑或向量变化的语言，正是矩阵&lt;/p&gt;

&lt;p&gt;线性空间中变化的实现有两种方式：一是点本身的变化，二是参考系的变化。
在第一种方式中，使某个点发生变化的方法是用代表变化的矩阵乘以代表对象的向量。而对坐标系施加变换的方法，就是让表示原始坐标系的矩阵与表示变换的矩阵相乘。&lt;/p&gt;

&lt;p&gt;描述矩阵的一对重要参数是&lt;code&gt;特征值&lt;/code&gt;和&lt;code&gt;特征向量&lt;/code&gt;。对于给定的矩阵$A$，假设其特征值为$\lambda$，特征向量为$\vec x$，则它们的关系如下：&lt;/p&gt;

&lt;p&gt;$A\vec x = \lambda\vec x$&lt;/p&gt;

&lt;p&gt;矩阵代表了向量的变换，其效果通常是对原始向量同时施加方向变化和尺度变化。可对于有些特殊的向量，矩阵的作用只有尺度变化而没有方向变化，也就是只有伸缩的效果而没有旋转的效果。对于给定的矩阵来说，这类特殊的向量就是矩阵的特征向量，特征向量的尺度变化系数就是特征值。&lt;/p&gt;

&lt;p&gt;求解给定矩阵的特征值和特征向量的过程叫做特征值分解，但能够进行特征值分解的矩阵必须是 n 维方阵。将特征值分解算法推广到所有矩阵之上，就是更加通用的奇异值分解。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性&lt;/li&gt;
  &lt;li&gt;向量的实质是 n 维线性空间中静止的点&lt;/li&gt;
  &lt;li&gt;线性变换描述向量或作为参考系的坐标的变化，可以用矩阵表示&lt;/li&gt;
  &lt;li&gt;矩阵的特征值和特征向量描述了变化的速度和方向&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210808.jpg&quot; alt=&quot;宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</guid>
        
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(1)</title>
        <description>&lt;h2 id=&quot;人工智能理解&quot;&gt;人工智能理解&lt;/h2&gt;

&lt;p&gt;建立在以线性代数和概率论为骨架的基础数学上，通过简单的模型组合实现复杂的功能。&lt;/p&gt;

&lt;h2 id=&quot;线性代数的核心意义&quot;&gt;线性代数的核心意义&lt;/h2&gt;

&lt;p&gt;万事万物都可以被抽象成某些特征的组合，并在由预置规则定义的框架之下以静态和动态的方式加以观察。&lt;/p&gt;

&lt;p&gt;用虚拟数字世界表示真实物理世界的工具。&lt;/p&gt;

&lt;h2 id=&quot;线性代数基本概念&quot;&gt;线性代数基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;集合(set)：某些特定对象汇总成的集体&lt;/li&gt;
  &lt;li&gt;标量(scalar)：单独数&lt;code&gt;a&lt;/code&gt;构成的元素，&lt;code&gt;a&lt;/code&gt;可以是&lt;code&gt;整数&lt;/code&gt;、&lt;code&gt;实数&lt;/code&gt;或&lt;code&gt;复数&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量(vector)：多个标量按一定顺序组成一个序列&lt;/p&gt;

    &lt;p&gt;向量可以看作标量的扩展，原始的数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一确定向量中的元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;矩阵(matrix)：交向量的所有标量都替换成同规格的向量&lt;/p&gt;

    &lt;p&gt;相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要两个索引确定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;张量(tensor)：将矩阵中的每个标量再替换为向量，得到的就是张量。张量就是高阶矩阵&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;描述向量的数学语言&quot;&gt;描述向量的数学语言&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;范数(norm)：对单个向量大小的度量，描述的是向量自身的性质，其作用是将向量映射为一个非负的数值。通用$L^p 范数定义如下：&lt;/p&gt;

    &lt;p&gt;$∣\vec x∣_p​ = (\sum_i∣x_i​∣^p)^\frac{1}{p}$​&lt;/p&gt;

    &lt;p&gt;对于一个给定的向量，$L^1$范数计算的是向量所有元素绝对值的和，$L^2$范数计算的是通常意义的向量长度，$L^\infty$范数计算的则是向量中最大元素的取值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内积(inner product)：计算的是两个向量的关系。两个同维向量内积的表达式为&lt;/p&gt;

    &lt;p&gt;$&amp;lt;\vec x, \vec y&amp;gt; = \sum_ix_i*y_i$&lt;/p&gt;

    &lt;p&gt;即对应元素乘积的求和。内积能表示两个向量的相对位置，即向量之间的夹角。一种特殊的情况是内积是 0，即$&amp;lt;\vec x, \vec y&amp;gt; = 0$，在二维空间上，这意味着两个向量夹角 90 度，即相互垂直。而在高维空间上，这咱关系被称为&lt;code&gt;正交(orthogonality)&lt;/code&gt;。如果两个向量正交，说明它们线性无关，相互独立，互不影响。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
</description>
        <pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</guid>
        
        
        <category>AI</category>
        
        <category>线性代数</category>
        
      </item>
    
      <item>
        <title>Git Add</title>
        <description>&lt;p&gt;Add a folder to git with exceptions&lt;/p&gt;

&lt;p&gt;Given this folder structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
├── bin
│  └── parse-ansi-codes.rs
├── Cargo.lock
├── Cargo.toml
├── README.md
├── src
│  ├── cursor.rs
│  ├── lib.rs
│  └── style.rs
├── target
│  └── debug
└── test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can add the entire &lt;code&gt;app&lt;/code&gt; directory to git, while ignoring the bin folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add . ':!bin'
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210805.jpg&quot; alt=&quot;宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/git_add_with_exceptions</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_add_with_exceptions</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>Git Proxy</title>
        <description>&lt;h2 id=&quot;http-代理&quot;&gt;HTTP 代理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git config --global http.proxy 127.0.0.1:1080
git config --global https.proxy 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ssh-代理&quot;&gt;SSH 代理&lt;/h2&gt;

&lt;p&gt;SSH 代理需要在密钥目录&lt;code&gt;~/.ssh&lt;/code&gt;(Windows 下是&lt;code&gt;C:\Users\{UserName}\.ssh&lt;/code&gt;)新建一个&lt;code&gt;config&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cat ~/.ssh/config
Host github.com
    ProxyCommand connect -S 127.0.0.1:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210803.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/git_proxy</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_proxy</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>VS Code的使用</title>
        <description>&lt;h2 id=&quot;vs-code-快捷键&quot;&gt;VS Code 快捷键&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标移动&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;方向键&lt;/code&gt;: 在&lt;strong&gt;单个字符&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + 左右方向键&lt;/code&gt;): 在&lt;strong&gt;单词&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Home/End&lt;/code&gt;): 把光标移动到行首或者行末&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + Shift + \&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Shift + \&lt;/code&gt;): 光标在&lt;strong&gt;代码块&lt;/strong&gt;的始末跳转&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 上下方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Home/End&lt;/code&gt;): 光标移动到文档的第一行或者最后一行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本选择&lt;/p&gt;

    &lt;p&gt;只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除整行(剪切 Cmd+X 也可用于删除整行)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行下面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行上面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上复制&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下复制&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义快捷键&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;Cmd+K, Cmd+S&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl+K, Ctrl+S&lt;/code&gt;)打开”Keyboard Shortcuts”窗口修改&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Backspace&lt;/code&gt; 删除光标之前的整行内容(Delete All Left)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Delete&lt;/code&gt; 删除光标之后的整行内容(Delete All Right)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Shift + ]&lt;/code&gt; 选择括号内所有内容(Select to Bracket)&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + U&lt;/code&gt; Transform to Uppercase&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + L&lt;/code&gt; Transform to Lowercase&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20191012.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/VSCode</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/VSCode</guid>
        
        
        <category>vscode</category>
        
        <category>editor</category>
        
      </item>
    
      <item>
        <title>用nginx代理phoenix应用</title>
        <description>&lt;h2 id=&quot;upstream-proxy&quot;&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream&quot;&gt;upstream proxy&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;upstream fvlandingpagebygeo_phoenix {
  server 127.0.0.1:8900
}

server {
  server_name fvlandingpagebygeo.com www.fvlandingpagebygeo.com;

  listen 80 default_server;
  listen [::]:80 default_server;

  root /srv/www/fvlandingpagebygeo.com/htdocs;
  index index.html;

  location / {
    # pass the requests on to our proxy
    try_files $uri @proxy;
  }
  
  location @proxy {
    include proxy_params;
    proxy_redirect off;
    proxy_pass http://fvlandingpagebygeo_phoenix;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;phoenix应用作为子目录&quot;&gt;phoenix应用作为子目录&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;nginx配置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

location ~ /(phx|phoenix) {
  proxy_pass http://127.0.0.1:4000;
  # Proxy Headers
  proxy_redirect off;
  proxy_http_version 1.1;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $http_host;
  proxy_set_header X-Cluster-Client-Ip $remote_addr;

  # WebSockets
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection $connection_upgrade;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xiaobin0860/phx_umbrella/commit/bf348686bdfd19a39e81fb293ab00974e9ee6471&quot;&gt;phx app修改&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;any compiled assets need to be prefixed with the subdirectory&lt;/li&gt;
  &lt;li&gt;any reference to those assets needs to be prefixed with the subdirectory&lt;/li&gt;
  &lt;li&gt;all links should be prefixed with the subdirector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://geoffreylessel.com/2016/hosting-a-phoenix-app-in-a-subdirectory-with-nginx/&quot;&gt;Hosting A Phoenix App In A Subdirectory With Nginx&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20190406.jpg&quot; alt=&quot;宝宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/phx_nginx</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/phx_nginx</guid>
        
        
        <category>phoenix</category>
        
        <category>nginx</category>
        
      </item>
    
      <item>
        <title>Vim Format</title>
        <description>&lt;h2 id=&quot;vim-format&quot;&gt;vim format&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;gg 跳转到第一行&lt;/li&gt;
  &lt;li&gt;shift+v 转到可视模式&lt;/li&gt;
  &lt;li&gt;shift+g 全选&lt;/li&gt;
  &lt;li&gt;按下神奇的 =&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20180528.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/vim_format</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/vim_format</guid>
        
        
        <category>vim</category>
        
      </item>
    
  </channel>
</rss>
