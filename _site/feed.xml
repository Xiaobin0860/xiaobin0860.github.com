<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>https://xiaobin0860.github.io/</link>
    <atom:link href="https://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 12 Feb 2023 23:00:53 +0800</pubDate>
    <lastBuildDate>Sun, 12 Feb 2023 23:00:53 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>Redis数据结构</title>
        <description>&lt;h2 id=&quot;redis数据类型及底层数据结构&quot;&gt;Redis数据类型及底层数据结构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;String(字符串)：动态字符串 O(1)&lt;/li&gt;
  &lt;li&gt;List(列表)：双向链表，压缩列表&lt;/li&gt;
  &lt;li&gt;Hash(哈希)：哈希表，压缩列表&lt;/li&gt;
  &lt;li&gt;Set(集合)：哈希表，整数数组&lt;/li&gt;
  &lt;li&gt;Sorted Set(有序集合)：跳表，压缩列表&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redis键值结构&quot;&gt;Redis键值结构&lt;/h2&gt;

&lt;p&gt;全局哈希表，实现从键到值的快速访问
&lt;code&gt;写入大量数据变慢：哈希冲突、rehash&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;哈希表 O(1)  String&lt;/li&gt;
  &lt;li&gt;整数数组和双向链表 O(n)&lt;/li&gt;
  &lt;li&gt;压缩列表 &lt;code&gt;zlbytes|zltail|zllen|entry1|entry2|..|entryN|zlend&lt;/code&gt; O(n)&lt;/li&gt;
  &lt;li&gt;跳表 在链表基础上增加多级索引，实现快速定位 O(logN)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;redis操作复杂度总结&quot;&gt;Redis操作复杂度总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;单元素操作是基础 O(1)&lt;/li&gt;
  &lt;li&gt;范围操作非常耗时 O(N)&lt;/li&gt;
  &lt;li&gt;统计操作非常高效 O(1)&lt;/li&gt;
  &lt;li&gt;List头尾操作 O(1)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 12 Feb 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</guid>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>键值数据库基本架构</title>
        <description>&lt;h2 id=&quot;考虑的问题&quot;&gt;考虑的问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;数据类型&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Redis 支持的 value 类型包括了 String、哈希表、列表、集合等&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;PUT/GET/DELETE/SCAN 是一个键值数据库的基本操作集合&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;数据存储&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;内存：访问速度快(百ns)，掉电易失
外存：避免数据丢失，受限于磁盘的慢速读写(几ms级别)，性能低&lt;/p&gt;

&lt;h2 id=&quot;基本架构&quot;&gt;基本架构&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;访问框架&lt;/li&gt;
  &lt;li&gt;操作模块&lt;/li&gt;
  &lt;li&gt;索引模块&lt;/li&gt;
  &lt;li&gt;存储模块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://static001.geekbang.org/resource/image/30/44/30e0e0eb0b475e6082dd14e63c13ed44.jpg?wh=5319*3582&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 12 Feb 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/redis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%9E%B6</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/redis%E5%9F%BA%E6%9C%AC%E6%9E%84%E6%9E%B6</guid>
        
        
        <category>redis</category>
        
      </item>
    
      <item>
        <title>c++ Concepts</title>
        <description>&lt;h2 id=&quot;泛型编程&quot;&gt;泛型编程&lt;/h2&gt;

&lt;p&gt;长期以来，软件重用一直都是软件工程追求的目标，而泛型编程为软件重用创造了可能性。所谓泛型编程，指的是通过组件的灵活组合来实现软件，而这些组件通过对定义做出最小“假设”来实现最大灵活性。&lt;/p&gt;

&lt;h2 id=&quot;c模板&quot;&gt;c++模板&lt;/h2&gt;

&lt;p&gt;在函数与类的定义 / 声明前，加上模板列表，在列表中指定在函数以及类的定义 / 声明中使用的模板参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//class/typename定义的T/U是类型参数，size_t定义的S是非类型参数
template&amp;lt;size_t S, class T, typename u&amp;gt;
void fill_container(T&amp;amp; container, U v) {
    for (size_t i=0;i&amp;lt;S;++i) {
        container.push_back(v);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;显示实例化，加快编译速度，其它编译单元直接用显示实例化的符号
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; template&amp;lt;typename T, typename U&amp;gt;
 void fill_container(T&amp;amp; container, U v, size_t s) {
     for (size_t i=0;i&amp;lt;s;++i) {
         container.push_back(v);
     }
 }
 template
 void fill_container&amp;lt;std::vector&amp;lt;int&amp;gt;, int&amp;gt;(std::vector&amp;lt;int&amp;gt;&amp;amp;, int, size_t);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;特化 为特定参数类型提供特定实现版本，提供类似函数重载的支持
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; template&amp;lt;size_t Size, class T, typename U&amp;gt;
 void fill(T&amp;amp; collection, U value) {
     std::cout &amp;lt;&amp;lt; &quot;Universal&quot; &amp;lt;&amp;lt; std::endl;
     for (size_t i = 0; i != Size; ++i) {
         collection.push_back(value);
     }
 }
 template &amp;lt;&amp;gt;
 void fill&amp;lt;10, std::vector, double&amp;gt;(std::vector&amp;amp; collection, double value) {
     std::cout &amp;lt;&amp;lt; &quot;Explicit (full) template specialization&quot; &amp;lt;&amp;lt; std::endl;
     for (size_t i = 0; i != 10; ++i) {
         collection.push_back(value + 2.0);
     }
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;偏特化&lt;/li&gt;
  &lt;li&gt;不定参模板
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; double sum() {
     return 0.0;
 }
 template &amp;lt;typename T, typename... Targs&amp;gt;
 double sum(T value, Targs... Fargs) {
     return static_cast&amp;lt;double&amp;gt;(value) + sum(Fargs...);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;类型约束晦涩难懂&lt;/li&gt;
  &lt;li&gt;生成的代码急速膨胀&lt;/li&gt;
  &lt;li&gt;ABI 兼容性糟糕 接口不要使用STL&lt;/li&gt;
  &lt;li&gt;错误消息很难理解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;concepts&quot;&gt;Concepts&lt;/h2&gt;

&lt;p&gt;解决问题1和4，将一组通用的约束定义为一个&lt;code&gt;concept&lt;/code&gt;，并且，在定义模板函数与模板类中，直接使用这些&lt;code&gt;concept&lt;/code&gt;替换通用的&lt;code&gt;typename&lt;/code&gt;和&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;参数模板&amp;gt;
concept 名称 = 约束表达式;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class BaseClass {
public:
    int32_t getValue() const {
        return 1;
    }
};
template&amp;lt;class T&amp;gt;
concept DerivedOfBaseClass = std::is_base_of_v&amp;lt;BaseClass, T&amp;gt;;

template &amp;lt;DerivedOfBaseClass T&amp;gt;
void doGetValue(const T&amp;amp; a) {
    std::cout &amp;lt;&amp;lt; &quot;Get value:&quot; &amp;lt;&amp;lt; a.getValue() &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;通过约束与 concept 这两个 C++ 核心语言特性变更（高级抽象），实现了对模板参数列表与参数的约束的逻辑分离&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;从 C++20 标准及其演进标准之后，concept 之于 C++ 泛型编程，正如 class 之于 C++ 面向对象&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;约束表达式&quot;&gt;约束表达式&lt;/h2&gt;

&lt;p&gt;通过逻辑操作符的方式进行组合的，用于定义更复杂的 concept&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;class T&amp;gt;
concept Integral = std::is_integral_v&amp;lt;T&amp;gt;;
 
template&amp;lt;class T&amp;gt;
concept SignedIntegral = Integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; std::is_signed_v&amp;lt;T&amp;gt;;
 
template&amp;lt;class T&amp;gt;
concept UnsignedIntegral = Integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; !SignedIntegral&amp;lt;T&amp;gt;;
 
template &amp;lt;class T&amp;gt;
concept FloatingPoint = std::is_floating_point_v&amp;lt;T&amp;gt;;
 
template &amp;lt;class T&amp;gt;
concept Number = Integral&amp;lt;T&amp;gt; || FloatingPoint&amp;lt;T&amp;gt;;

template&amp;lt;typename T&amp;gt;
constexpr bool get_value() { return T::value; }
template&amp;lt;typename T&amp;gt;
    requires (sizeof(T) &amp;gt; 1 &amp;amp;&amp;amp; get_value&amp;lt;T&amp;gt;())
void f(T) {
    std::cout &amp;lt;&amp;lt; &quot;template version&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Feb 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/c++20_Concepts</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/c++20_Concepts</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>c++ Modules</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;现在模块化编程，替代头文件，解决模块间符号可见性控制问题&lt;/p&gt;

&lt;h2 id=&quot;模块声明&quot;&gt;模块声明&lt;/h2&gt;

&lt;p&gt;编译单元默认&lt;code&gt;普通单元&lt;/code&gt;，&lt;code&gt;module&lt;/code&gt;关键字&lt;code&gt;模块单元&lt;/code&gt;，&lt;code&gt;export module&lt;/code&gt;定义模块对外接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;export module helloworld;
//符号默认对模块外不可见
void private_hello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; std::endl;
}
//定义外部可见函数
export void hello() {
    private_hello():
}
//导出整个namespace，不推荐
export namespace hname {
    int get_num() {
        return 0;
    }
}
//推荐namespace内细粒度控制
namespace xname {
    export int get_num() {
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;导入模块&quot;&gt;导入模块&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;关键字导入模块，让被引用模块的符号在本编译单元可见，类似&lt;code&gt;using namespace&lt;/code&gt;，可以用&lt;code&gt;export import&lt;/code&gt;将导入符号对外导出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;///bye.cpp
export module bye;
import &amp;lt;iostream&amp;gt;
export void goodbye() {
    std::cout &amp;lt;&amp;lt; &quot;Goodbye&quot; &amp;lt;&amp;lt; std::endl;
}

///helloworld.cpp
export module helloworld;
export import bye;
export void hello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; std::endl;
}

///main.cpp
import helloworld;
int main() {
    helloe();
    goodbye();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;导入头文件&quot;&gt;导入头文件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;与&lt;code&gt;include&lt;/code&gt;区别是，通过&lt;code&gt;impor&lt;/code&gt;导入头文件的编译单元定义的&lt;code&gt;预处理宏&lt;/code&gt;，是无法被&lt;code&gt;import&lt;/code&gt;导入的文件访问的，可以用&lt;code&gt;模块片段&lt;/code&gt;来实现使用&lt;code&gt;预处理宏&lt;/code&gt;影响头文件&lt;/p&gt;

&lt;p&gt;全局模块片段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;module;
//预处理宏指令
//模块声明
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;模块分区&quot;&gt;模块分区&lt;/h2&gt;

&lt;p&gt;模块的一个关键特性是可以划分为更多的子模块。在 C++ Modules 中，子模块主要有两种实现方式：通过模块名称进行区分(&lt;code&gt;utils.image&lt;/code&gt;)、利用模块分区特性(&lt;code&gt;模块名:分区名&lt;/code&gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//helloworld_a.cpp
export module helloworld:A;

//helloworld_b.cpp
export module helloworld:B

//helloworld.cpp
export module helloworld;
export import :A;
import :B;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;模块所有权&quot;&gt;模块所有权&lt;/h2&gt;

&lt;p&gt;使用模块的时候需要注意符号声明的所有权问题，这影响符号的实现位置和符号的&lt;code&gt;链接性(linkage)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;export module lib;
namespace hello { //命名空间不属于lib
    extern &quot;C++&quot; int32_t f(); //外部链接c++方式符号，不属于lib
    extern &quot;C&quot; int32_t g(); //外部链接c方式符号，不属于lib
    int32_t x(); //hello::x属于lib，只能被同模块编译单元使用
    export int32_t z(); //hello::z属于lib，可被其它模块编译单元使用
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 06 Feb 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/c++20_Modules</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/c++20_Modules</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>栈</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种“操作受限”的线性表，只允许从一端插入删除数据&lt;/li&gt;
  &lt;li&gt;后进先出，先进后出&lt;/li&gt;
  &lt;li&gt;顺序栈(数组)，链式栈(链表)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;入栈 O(1)&lt;/li&gt;
  &lt;li&gt;出栈 O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态扩容&quot;&gt;动态扩容&lt;/h2&gt;

&lt;p&gt;底层动态扩容数组，栈满后申请更大空间，进行数据搬移&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;函数调用栈&lt;/li&gt;
  &lt;li&gt;表达式求值&lt;/li&gt;
  &lt;li&gt;括号匹配&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 29 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E6%A0%88</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E6%A0%88</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>链表</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种线性表数据结构&lt;/li&gt;
  &lt;li&gt;用&lt;code&gt;指针&lt;/code&gt;将一组零散的内存块(&lt;code&gt;结点&lt;/code&gt;)串联起来使用&lt;/li&gt;
  &lt;li&gt;插入、删除数据非常快速&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;单链表
    &lt;ul&gt;
      &lt;li&gt;查找 O(n)&lt;/li&gt;
      &lt;li&gt;插入和删除 O(1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;循环链表 尾结点&lt;code&gt;next&lt;/code&gt;指向头结点&lt;/li&gt;
  &lt;li&gt;双向链表 &lt;code&gt;next&lt;/code&gt;后继指针，&lt;code&gt;prev&lt;/code&gt;前驱指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;链表适合插入、删除操作频繁的场景&lt;/li&gt;
  &lt;li&gt;双向链表比单链表插入、删除等操作简单、高效，适用更多情况&lt;/li&gt;
  &lt;li&gt;循环链表适合处理具有环型特点的数据，比如约瑟夫问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;练习&quot;&gt;练习&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单链表反转&lt;/li&gt;
  &lt;li&gt;链表中环的检测&lt;/li&gt;
  &lt;li&gt;两个有序链表合并&lt;/li&gt;
  &lt;li&gt;删除链表倒数第 n 个结点&lt;/li&gt;
  &lt;li&gt;求链表的中间结点&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;编码技巧&quot;&gt;编码技巧&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;理解指针和引用的含义(地址)&lt;/li&gt;
  &lt;li&gt;警惕指针丢失和内存泄露&lt;/li&gt;
  &lt;li&gt;利用哨兵简化实现难度&lt;/li&gt;
  &lt;li&gt;重点留意边界条件处理&lt;/li&gt;
  &lt;li&gt;举例画图，辅助思考&lt;/li&gt;
  &lt;li&gt;多写多练，没有捷径&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 29 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E9%93%BE%E8%A1%A8</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E9%93%BE%E8%A1%A8</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>算法复杂度分析</title>
        <description>&lt;p&gt;数据结构和算法解决的是快和省的问题，即如何让代码运行得更快，更省存储空间。
可以用时间、空间复仇度分析来衡量算法好坏。&lt;/p&gt;

&lt;h2 id=&quot;大-o-复杂度表示法&quot;&gt;大 O 复杂度表示法&lt;/h2&gt;

&lt;p&gt;所有代码的执行时间&lt;code&gt;T(n)&lt;/code&gt;与每行代码的执行次数&lt;code&gt;f(n)&lt;/code&gt;成正比&lt;/p&gt;

&lt;p&gt;$T(n) = O(f(n))$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;大O时间复杂度&lt;/code&gt;表示代码执行时间随数据规模增长的变化趋势，也叫&lt;code&gt;渐进时间复杂度&lt;/code&gt;，简称&lt;code&gt;时间复杂度&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;只关注循环执行次数最多的一段代码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加法法则：总复杂度等于量级最大的那段代码的复杂度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;常见复杂度案例&quot;&gt;常见复杂度案例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多项式量级&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;常量阶$O(1)$&lt;/li&gt;
      &lt;li&gt;对数阶$O(log_n)$&lt;/li&gt;
      &lt;li&gt;线性阶$O(n)$&lt;/li&gt;
      &lt;li&gt;线性对数阶$O(nlog_n)$&lt;/li&gt;
      &lt;li&gt;平方阶$O(n^2)$、立方阶$O(n^3)$…k 次方阶$O(n^k)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非多项式量级&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;指数阶$O(2^n)$&lt;/li&gt;
      &lt;li&gt;阶乘阶$O(n!)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;最好最坏情况时间复杂度&quot;&gt;(最好/最坏)情况时间复杂度&lt;/h2&gt;

&lt;p&gt;在(最理想/最糟糕)的情况下，执行这段代码的时间复杂度。&lt;/p&gt;

&lt;h2 id=&quot;平均情况时间复杂度&quot;&gt;平均情况时间复杂度&lt;/h2&gt;

&lt;p&gt;将各种情况发生的概率考虑进去，做加权平均。&lt;/p&gt;

&lt;h2 id=&quot;均摊时间复杂度&quot;&gt;均摊时间复杂度&lt;/h2&gt;

&lt;p&gt;特殊的平均时间复杂度&lt;/p&gt;

&lt;p&gt;每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。&lt;/p&gt;

&lt;h2 id=&quot;空间复杂度分析&quot;&gt;空间复杂度分析&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;空间复杂度&lt;/code&gt;全称是&lt;code&gt;渐进空间复杂度&lt;/code&gt;，表示算法的存储空间与数据规模之间的增长关系。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>数组</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种线性表数据结构&lt;/li&gt;
  &lt;li&gt;用一组连续内存，存储相同类型的数据&lt;/li&gt;
  &lt;li&gt;支持随机访问，但插入删除低效&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;h3 id=&quot;随机访问&quot;&gt;随机访问&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一维寻址公式：a[k]_address = base_address + k * type_size&lt;/li&gt;
  &lt;li&gt;二维寻址公式：对m * n数组，a[i][j] = base_address + (i * n + j) * type_size&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;插入操作&quot;&gt;插入操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最坏(在开头插入)O(n)，平均O(n)&lt;/li&gt;
  &lt;li&gt;最好(在末尾插入)O(1)&lt;/li&gt;
  &lt;li&gt;无序在第k位插入，可第k位插最后，写入第k位，O(1)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;删除操作&quot;&gt;删除操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最坏(在开头删除)O(n)，平均O(n)&lt;/li&gt;
  &lt;li&gt;最好(在末尾删除)O(1)&lt;/li&gt;
  &lt;li&gt;标记删除，以后触发真正删除操作，均摊&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;平时开发直接用编程语言提供的容器&lt;/li&gt;
  &lt;li&gt;特别底层开发，直接使用数组&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 11 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E6%95%B0%E7%BB%84</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E6%95%B0%E7%BB%84</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>类型系统</title>
        <description>&lt;h2 id=&quot;primitive-type&quot;&gt;primitive type&lt;/h2&gt;

&lt;p&gt;基本类型：interger, string, bool, array …&lt;/p&gt;

&lt;h2 id=&quot;product-type&quot;&gt;product type&lt;/h2&gt;

&lt;p&gt;struct 不同类型的乘积，取值是所有组合类型的笛卡尔积&lt;/p&gt;

&lt;h2 id=&quot;sum-type&quot;&gt;sum type&lt;/h2&gt;

&lt;p&gt;enum 不同类型的不相交集&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Option&amp;lt;T&amp;gt; {
   Some(T),
   None
}
enum Result&amp;lt;T, E&amp;gt; {
   Ok(T),
   Err(E)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;generic-type&quot;&gt;generic type&lt;/h2&gt;

&lt;p&gt;泛型，提升抽象程度，可看成是作用于类型的的特殊函数，
展开为新类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt;展开是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Option {
   Some(u8),
   None
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 06 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/types</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/types</guid>
        
        
        <category>rust</category>
        
      </item>
    
      <item>
        <title>lua入门</title>
        <description>&lt;h2 id=&quot;首先介绍一下-lua-语言&quot;&gt;首先介绍一下 lua 语言：&lt;/h2&gt;

&lt;p&gt;它是一门动态类型语言。所谓动态就是运行时，静态就是编译时。&lt;br /&gt;
静态语言会在编译时做类型检查，通过报错帮助程序员发现问题。&lt;br /&gt;
动态语言没有编译环节，类型检查发生在运行时，查到错误就会抛出异常，&lt;br /&gt;
程序员需要自己保证类型正确，或者做好异常处理。&lt;br /&gt;
因为没有类型的约束，lua 语言非常灵活，可以编写一些复杂的逻辑。&lt;br /&gt;
除了动态语言共同的优势以外，lua 自身有两大优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尾调用，使得程序员可以放心的写递归算法，不必担心 StackOverflow&lt;/li&gt;
  &lt;li&gt;标准化的 c api，使得 lua 语言可以与 c 语言互相调用，并且所写的 c 代码是跨平台的，不会因 lua 解释器不同而不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一类型系统分为值类型和引用对象类型&quot;&gt;一、类型系统分为“值类型”和“引用（对象）类型”&lt;/h2&gt;

&lt;p&gt;值类型有 5 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;nil&lt;/code&gt;类型，值也是&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;类型，值为&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;number&lt;/code&gt;类型，默认由&lt;code&gt;double&lt;/code&gt;类型实现。&lt;code&gt;m^n&lt;/code&gt;，求&lt;code&gt;m&lt;/code&gt;的&lt;code&gt;n&lt;/code&gt;次方&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;类型，&lt;code&gt;&apos;\0&apos;&lt;/code&gt;字符不会截断字符串，可以用&lt;code&gt;&apos;&lt;/code&gt;、&lt;code&gt;&quot;&lt;/code&gt;、&lt;code&gt;[[]]&lt;/code&gt;来构造字符串。&lt;br /&gt;
&lt;code&gt;#str&lt;/code&gt;，求 str 的字节数。&lt;code&gt;str=str..str&lt;/code&gt;，连接两个字符串&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lightuserdata&lt;/code&gt;类型，对应 C 语言的指针值，是值不是对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;引用类型有 4 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;function&lt;/code&gt;类型，用&lt;code&gt;function(参数列) end&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;类型，用&lt;code&gt;{}&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;thread&lt;/code&gt;类型，不是线程，是协程，不具有并发功能，只能用来分隔不相干的逻辑。&lt;br /&gt;
每个&lt;code&gt;thread&lt;/code&gt;有自己的&lt;code&gt;call stack&lt;/code&gt;。由程序员调度所要执行的&lt;code&gt;thread&lt;/code&gt;，其它&lt;code&gt;thread&lt;/code&gt;会暂停&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;userdata&lt;/code&gt;类型，Cocos2dx 里的 c++类的实例，在 lua 里就是这种类型。&lt;br /&gt;
对比&lt;code&gt;lightuserdata&lt;/code&gt;，一个是指针本身（32 位或 64 位无符号整数），一个是指针指向的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二function-相关知识&quot;&gt;二、function 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;传参和传返回值的时候，根据上一讲分的两大类，来传值或传引用。&lt;/li&gt;
  &lt;li&gt;除了传参和传返回值，&lt;code&gt;function&lt;/code&gt;还会自动捕获外部的变量，术语叫&lt;code&gt;upvalue&lt;/code&gt;，意思是上文中的变量。&lt;br /&gt;
&lt;code&gt;upvalue&lt;/code&gt; 一律传引用，也就是说，在函数内修改&lt;code&gt;upvalue&lt;/code&gt;，那么函数外也能看到这一改变。&lt;br /&gt;
利用自动捕获，&lt;code&gt;function&lt;/code&gt;可以当做容器用，要访问容器中的变量，就必须调用该函数，以达到封装的目的&lt;br /&gt;
lua 中很少做封装，常做的只有继承、多态。&lt;/li&gt;
  &lt;li&gt;尾调用。函数内出现&lt;code&gt;return func(...)&lt;/code&gt;，那么调用栈会先 pop 当前函数，然后把 func 压入调用栈。&lt;br /&gt;
这一机制的好处是，可以无限制使用递归算法，而不会发生 stack overflow。&lt;br /&gt;
坏处是，调用栈不完整，在栈上看到一个函数，难以推断是哪个函数调用了这一函数，&lt;br /&gt;
因为上一个函数可能已经出栈了。写或不写 return，可以控制是否使用尾调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三table-相关知识&quot;&gt;三、table 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;是哈希表，无序容器。当键是从 1 开始的连续整数时，可以当做数组来用（有序）&lt;/li&gt;
  &lt;li&gt;与函数自动捕获引用不同，table 可以存值进去&lt;/li&gt;
  &lt;li&gt;增、改：&lt;code&gt;t[k]=v&lt;/code&gt;&lt;br /&gt;
删：&lt;code&gt;t[k]=nil&lt;/code&gt;&lt;br /&gt;
查：&lt;code&gt;if t[k]~= nil then ...&lt;/code&gt;&lt;br /&gt;
无序遍历：&lt;code&gt;for k,v in pairs(t) do ...&lt;/code&gt;&lt;br /&gt;
有序遍历：&lt;code&gt;for i,v in ipairs(t) do ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setmetatable(t,mt)&lt;/code&gt;用来给表 t 设置一个元表 mt，元表中存放的主要是元方法，&lt;br /&gt;
比如&lt;code&gt;__add&lt;/code&gt;, &lt;code&gt;__sub&lt;/code&gt;, &lt;code&gt;__mul&lt;/code&gt;, &lt;code&gt;__div&lt;/code&gt;, &lt;code&gt;__len&lt;/code&gt;, &lt;code&gt;__concat&lt;/code&gt;, &lt;code&gt;__gc&lt;/code&gt;。&lt;br /&gt;
前面几个相当于“运算符重载”，使 t 可以支持算术运算。gc 是垃圾回收的意思，相当于 t 的析构函数。&lt;br /&gt;
可以看出，mt 控制着 t 的行为&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四类与类的实例&quot;&gt;四、类与类的实例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;二者都是&lt;code&gt;table&lt;/code&gt;，前者装有成员函数（共性），后者装有成员变量（个性）&lt;/li&gt;
  &lt;li&gt;语法糖 &lt;code&gt;instance:method(argument)&lt;/code&gt;&lt;br /&gt;
原型为 &lt;code&gt;instance[&apos;method&apos;](instance,argument)&lt;/code&gt;&lt;br /&gt;
先在实例表里查找成员函数，通常表里只有成员变量没有成员函数，这种情况下会触发&lt;code&gt;__index&lt;/code&gt;元方法，&lt;br /&gt;
元方法去类表里继续查找，若依然找不到，再触发类表的&lt;code&gt;__index&lt;/code&gt;元方法，一路找下去。&lt;br /&gt;
找到之后，就把实例表、实参传入这个函数，于是函数内就能访问到成员变量了&lt;/li&gt;
  &lt;li&gt;语法糖&lt;code&gt;instance.method(argument)&lt;/code&gt;&lt;br /&gt;
原型为&lt;code&gt;instance[&apos;method&apos;](argument)&lt;/code&gt;&lt;br /&gt;
这相当于其它语言中调用&lt;code&gt;static&lt;/code&gt;成员函数，没有成员变量传入函数。&lt;br /&gt;
或者&lt;code&gt;class:method(argument)&lt;/code&gt;类表会被传入函数，&lt;br /&gt;
static 成员变量应该存放在类表里，并且可以被 static 成员函数访问&lt;/li&gt;
  &lt;li&gt;上面的 class 指代一个类表，在 cocos 中，class 是一个全局函数，由 cocos 引擎提供。&lt;br /&gt;
这个函数的作用是返回一个新的类表，并为其设置好：元方法&lt;code&gt;__index&lt;/code&gt;（去父类中查找）、&lt;br /&gt;
static 成员函数&lt;code&gt;create&lt;/code&gt;（创建实例对象）、static 成员函数&lt;code&gt;new&lt;/code&gt;（创建实例对象）、&lt;br /&gt;
一般成员函数&lt;code&gt;ctor&lt;/code&gt;（在实例对象中放入初始内容）。&lt;br /&gt;
实例对象可能是&lt;code&gt;table&lt;/code&gt;或&lt;code&gt;userdata&lt;/code&gt;，而类一定是&lt;code&gt;table&lt;/code&gt;。&lt;br /&gt;
Cocos 引擎创建&lt;code&gt;userdata&lt;/code&gt;的时候，总是同时创建一个&lt;code&gt;table&lt;/code&gt;，并将二者绑在一起，&lt;br /&gt;
所以可以对&lt;code&gt;userdata&lt;/code&gt;使用&lt;code&gt;table&lt;/code&gt;语法&lt;/li&gt;
  &lt;li&gt;上面说的语法糖，不止用于函数调用，也用于函数定义：
    &lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;local class = {}
function class:ctor(sth)
self.field = sth
end
--等价于：
local class = {}
function class.ctor(self, sth)
self.field = sth
end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;lua 中任意类型的值都可以代表真假。只有&lt;code&gt;nil&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;两个值代表假，其它值都代表真。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;and&lt;/code&gt;和&lt;code&gt;or&lt;/code&gt;运算符，不会把它们所连接的表达式转成&lt;code&gt;boolean&lt;/code&gt;型，这一点跟其他语言不同。&lt;br /&gt;
&lt;code&gt;a and b or c&lt;/code&gt;与其它语言的 &lt;code&gt;a ? b : c&lt;/code&gt;功能类似，具体是：若 a 和 b 为真，则返回 b；&lt;br /&gt;
若 a 为假，则返回 c。若 a 为真，b 为假，则返回 c，这与&lt;code&gt;?:&lt;/code&gt;不同。&lt;/li&gt;
  &lt;li&gt;参考手册 https://www.lua.org/manual/5.1/&lt;/li&gt;
  &lt;li&gt;https://learnxinyminutes.com/docs/zh-cn/lua-cn/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 30 Apr 2022 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/lua</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/lua</guid>
        
        
        <category>lua</category>
        
      </item>
    
  </channel>
</rss>
