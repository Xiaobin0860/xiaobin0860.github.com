<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>https://xiaobin0860.github.io/</link>
    <atom:link href="https://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 30 Apr 2022 14:46:37 +0800</pubDate>
    <lastBuildDate>Sat, 30 Apr 2022 14:46:37 +0800</lastBuildDate>
    <generator>Jekyll v4.2.2</generator>
    
      <item>
        <title>lua入门</title>
        <description>&lt;h2 id=&quot;首先介绍一下-lua-语言&quot;&gt;首先介绍一下 lua 语言：&lt;/h2&gt;

&lt;p&gt;它是一门动态类型语言。所谓动态就是运行时，静态就是编译时。&lt;br /&gt;
静态语言会在编译时做类型检查，通过报错帮助程序员发现问题。&lt;br /&gt;
动态语言没有编译环节，类型检查发生在运行时，查到错误就会抛出异常，&lt;br /&gt;
程序员需要自己保证类型正确，或者做好异常处理。&lt;br /&gt;
因为没有类型的约束，lua 语言非常灵活，可以编写一些复杂的逻辑。&lt;br /&gt;
除了动态语言共同的优势以外，lua 自身有两大优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尾调用，使得程序员可以放心的写递归算法，不必担心 StackOverflow&lt;/li&gt;
  &lt;li&gt;标准化的 c api，使得 lua 语言可以与 c 语言互相调用，并且所写的 c 代码是跨平台的，不会因 lua 解释器不同而不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一类型系统分为值类型和引用对象类型&quot;&gt;一、类型系统分为“值类型”和“引用（对象）类型”&lt;/h2&gt;

&lt;p&gt;值类型有 5 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;nil&lt;/code&gt;类型，值也是&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;类型，值为&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;number&lt;/code&gt;类型，默认由&lt;code&gt;double&lt;/code&gt;类型实现。&lt;code&gt;m^n&lt;/code&gt;，求&lt;code&gt;m&lt;/code&gt;的&lt;code&gt;n&lt;/code&gt;次方&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;类型，&lt;code&gt;'\0'&lt;/code&gt;字符不会截断字符串，可以用&lt;code&gt;'&lt;/code&gt;、&lt;code&gt;&quot;&lt;/code&gt;、&lt;code&gt;[[]]&lt;/code&gt;来构造字符串。&lt;br /&gt;
&lt;code&gt;#str&lt;/code&gt;，求 str 的字节数。&lt;code&gt;str=str..str&lt;/code&gt;，连接两个字符串&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lightuserdata&lt;/code&gt;类型，对应 C 语言的指针值，是值不是对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;引用类型有 4 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;function&lt;/code&gt;类型，用&lt;code&gt;function(参数列) end&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;类型，用&lt;code&gt;{}&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;thread&lt;/code&gt;类型，不是线程，是协程，不具有并发功能，只能用来分隔不相干的逻辑。&lt;br /&gt;
每个&lt;code&gt;thread&lt;/code&gt;有自己的&lt;code&gt;call stack&lt;/code&gt;。由程序员调度所要执行的&lt;code&gt;thread&lt;/code&gt;，其它&lt;code&gt;thread&lt;/code&gt;会暂停&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;userdata&lt;/code&gt;类型，Cocos2dx 里的 c++类的实例，在 lua 里就是这种类型。&lt;br /&gt;
对比&lt;code&gt;lightuserdata&lt;/code&gt;，一个是指针本身（32 位或 64 位无符号整数），一个是指针指向的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二function-相关知识&quot;&gt;二、function 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;传参和传返回值的时候，根据上一讲分的两大类，来传值或传引用。&lt;/li&gt;
  &lt;li&gt;除了传参和传返回值，&lt;code&gt;function&lt;/code&gt;还会自动捕获外部的变量，术语叫&lt;code&gt;upvalue&lt;/code&gt;，意思是上文中的变量。&lt;br /&gt;
&lt;code&gt;upvalue&lt;/code&gt; 一律传引用，也就是说，在函数内修改&lt;code&gt;upvalue&lt;/code&gt;，那么函数外也能看到这一改变。&lt;br /&gt;
利用自动捕获，&lt;code&gt;function&lt;/code&gt;可以当做容器用，要访问容器中的变量，就必须调用该函数，以达到封装的目的&lt;br /&gt;
lua 中很少做封装，常做的只有继承、多态。&lt;/li&gt;
  &lt;li&gt;尾调用。函数内出现&lt;code&gt;return func(...)&lt;/code&gt;，那么调用栈会先 pop 当前函数，然后把 func 压入调用栈。&lt;br /&gt;
这一机制的好处是，可以无限制使用递归算法，而不会发生 stack overflow。&lt;br /&gt;
坏处是，调用栈不完整，在栈上看到一个函数，难以推断是哪个函数调用了这一函数，&lt;br /&gt;
因为上一个函数可能已经出栈了。写或不写 return，可以控制是否使用尾调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三table-相关知识&quot;&gt;三、table 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;是哈希表，无序容器。当键是从 1 开始的连续整数时，可以当做数组来用（有序）&lt;/li&gt;
  &lt;li&gt;与函数自动捕获引用不同，table 可以存值进去&lt;/li&gt;
  &lt;li&gt;增、改：&lt;code&gt;t[k]=v&lt;/code&gt;&lt;br /&gt;
删：&lt;code&gt;t[k]=nil&lt;/code&gt;&lt;br /&gt;
查：&lt;code&gt;if t[k]~= nil then ...&lt;/code&gt;&lt;br /&gt;
无序遍历：&lt;code&gt;for k,v in pairs(t) do ...&lt;/code&gt;&lt;br /&gt;
有序遍历：&lt;code&gt;for i,v in ipairs(t) do ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setmetatable(t,mt)&lt;/code&gt;用来给表 t 设置一个元表 mt，元表中存放的主要是元方法，&lt;br /&gt;
比如&lt;code&gt;__add&lt;/code&gt;, &lt;code&gt;__sub&lt;/code&gt;, &lt;code&gt;__mul&lt;/code&gt;, &lt;code&gt;__div&lt;/code&gt;, &lt;code&gt;__len&lt;/code&gt;, &lt;code&gt;__concat&lt;/code&gt;, &lt;code&gt;__gc&lt;/code&gt;。&lt;br /&gt;
前面几个相当于“运算符重载”，使 t 可以支持算术运算。gc 是垃圾回收的意思，相当于 t 的析构函数。&lt;br /&gt;
可以看出，mt 控制着 t 的行为&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四类与类的实例&quot;&gt;四、类与类的实例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;二者都是&lt;code&gt;table&lt;/code&gt;，前者装有成员函数（共性），后者装有成员变量（个性）&lt;/li&gt;
  &lt;li&gt;语法糖 &lt;code&gt;instance:method(argument)&lt;/code&gt;&lt;br /&gt;
原型为 &lt;code&gt;instance['method'](instance,argument)&lt;/code&gt;&lt;br /&gt;
先在实例表里查找成员函数，通常表里只有成员变量没有成员函数，这种情况下会触发&lt;code&gt;__index&lt;/code&gt;元方法，&lt;br /&gt;
元方法去类表里继续查找，若依然找不到，再触发类表的&lt;code&gt;__index&lt;/code&gt;元方法，一路找下去。&lt;br /&gt;
找到之后，就把实例表、实参传入这个函数，于是函数内就能访问到成员变量了&lt;/li&gt;
  &lt;li&gt;语法糖&lt;code&gt;instance.method(argument)&lt;/code&gt;&lt;br /&gt;
原型为&lt;code&gt;instance['method'](argument)&lt;/code&gt;&lt;br /&gt;
这相当于其它语言中调用&lt;code&gt;static&lt;/code&gt;成员函数，没有成员变量传入函数。&lt;br /&gt;
或者&lt;code&gt;class:method(argument)&lt;/code&gt;类表会被传入函数，&lt;br /&gt;
static 成员变量应该存放在类表里，并且可以被 static 成员函数访问&lt;/li&gt;
  &lt;li&gt;上面的 class 指代一个类表，在 cocos 中，class 是一个全局函数，由 cocos 引擎提供。&lt;br /&gt;
这个函数的作用是返回一个新的类表，并为其设置好：元方法&lt;code&gt;__index&lt;/code&gt;（去父类中查找）、&lt;br /&gt;
static 成员函数&lt;code&gt;create&lt;/code&gt;（创建实例对象）、static 成员函数&lt;code&gt;new&lt;/code&gt;（创建实例对象）、&lt;br /&gt;
一般成员函数&lt;code&gt;ctor&lt;/code&gt;（在实例对象中放入初始内容）。&lt;br /&gt;
实例对象可能是&lt;code&gt;table&lt;/code&gt;或&lt;code&gt;userdata&lt;/code&gt;，而类一定是&lt;code&gt;table&lt;/code&gt;。&lt;br /&gt;
Cocos 引擎创建&lt;code&gt;userdata&lt;/code&gt;的时候，总是同时创建一个&lt;code&gt;table&lt;/code&gt;，并将二者绑在一起，&lt;br /&gt;
所以可以对&lt;code&gt;userdata&lt;/code&gt;使用&lt;code&gt;table&lt;/code&gt;语法&lt;/li&gt;
  &lt;li&gt;上面说的语法糖，不止用于函数调用，也用于函数定义：
    &lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;local class = {}
function class:ctor(sth)
self.field = sth
end
--等价于：
local class = {}
function class.ctor(self, sth)
self.field = sth
end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;lua 中任意类型的值都可以代表真假。只有&lt;code&gt;nil&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;两个值代表假，其它值都代表真。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;and&lt;/code&gt;和&lt;code&gt;or&lt;/code&gt;运算符，不会把它们所连接的表达式转成&lt;code&gt;boolean&lt;/code&gt;型，这一点跟其他语言不同。&lt;br /&gt;
&lt;code&gt;a and b or c&lt;/code&gt;与其它语言的 &lt;code&gt;a ? b : c&lt;/code&gt;功能类似，具体是：若 a 和 b 为真，则返回 b；&lt;br /&gt;
若 a 为假，则返回 c。若 a 为真，b 为假，则返回 c，这与&lt;code&gt;?:&lt;/code&gt;不同。&lt;/li&gt;
  &lt;li&gt;参考手册 https://www.lua.org/manual/5.1/&lt;/li&gt;
  &lt;li&gt;https://learnxinyminutes.com/docs/zh-cn/lua-cn/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 30 Apr 2022 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/lua</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/lua</guid>
        
        
        <category>lua</category>
        
      </item>
    
      <item>
        <title>AI数学基础-信息论</title>
        <description>&lt;p&gt;信息论使用&lt;code&gt;信息熵&lt;/code&gt;的概念，对单个信号源的信息量和通讯中传递的信息的数量与效率等问题做出了解释，
并在世界的不确定性和信息的可测量性之间搭起一座桥梁。
&lt;code&gt;熵&lt;/code&gt;表示一个系统内在的混乱程度。&lt;/p&gt;

&lt;p&gt;事件$A$发生的概率为$p(A)$，则这个事件的&lt;code&gt;自信息量&lt;/code&gt;定义为
\(h(A) = -\log_2p(A)\)&lt;/p&gt;

&lt;p&gt;根据单个事件的自信息量可以计算出包含多个符号的信源的&lt;code&gt;信息熵&lt;/code&gt;。信源的信息熵是信源可能发出的各个符号的自信息量在信源构成的概率空间上的统计平均值。
如果一个信源$X$包含$n$个符号，每个符号$a_i$的取值为$p(a_i)$，则$X$的信源熵为
\(H(X) = -\sum_{i=1}^np(a_i)\log_2p(a_i)\)
信源熵描述了信源每发送一个符号所提供的平均信息量，是信源总体信息测度的均值。当信源中的每个符号的取值概率相等时，信源熵取到最大值$\log_2​n$，意味着信源的随机程度最高。&lt;/p&gt;

&lt;p&gt;在概率论中有&lt;code&gt;条件概率&lt;/code&gt;的概念，将条件概率扩展到信息论中，就可以得到&lt;code&gt;条件熵&lt;/code&gt;。如果两个信源之间具有相关性，那么在已知其中一个信源$X$的条件下，另一个信源$Y$的信源熵就会减小。
条件熵$H(Y∣X)$表示的是在已知随机变量$X$的条件下另一个随机变量$Y$的不确定性，也就是在给定$X$时，根据$Y$的条件概率计算出的熵再对$X$求解数学期望：&lt;/p&gt;

\[H(Y|X) = \sum_{i=1}^np(x_i)H(Y|X=x_i) \\
= -\sum_{i=1}^np(x_i)\sum_{j=1}^mp(y_j|x_i)\log_2p(y_j|x_i) \\
= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log_2p(y_j|x_i)\]

&lt;p&gt;条件熵的意义在于先按照变量$X$的取值对变量$Y$进行了一次分类，对每个分出来的类别计算其单独的信息熵，再将每个类的信息熵按照$X$的分布计算其数学期望。分类带来不确定性下降。&lt;/p&gt;

&lt;p&gt;定义了条件信息熵后，就可以进一步得到&lt;code&gt;互信息&lt;/code&gt;的概念
\(I(X;Y) = H(Y)-H(Y|X)\)
互信息等于$Y$的信源熵减去已知$X$时$Y$的条件熵，即由$X$提供的关于$Y$的不确定性的消除，也可以看成是$X$给$Y$带来的&lt;code&gt;信息增益&lt;/code&gt;。互信息这个名称在通信领域经常使用，信息增益则在机器学习领域中经常使用，两者的本质是一样的。&lt;/p&gt;

&lt;p&gt;在机器学习中，信息增益常常被用于分类特征的选择。对于给定的训练数据集$Y$，$H(Y)$表示在未给定任何特征时，对训练集进行分类的不确定性；$H(Y∣X)$则表示了使用特征$X$对训练集$Y$进行分类的不确定性。信息增益表示的就是特征$X$带来的对训练集$Y$分类不确定性的减少程度，也就是特征$X$对训练集$Y$的区分度。&lt;/p&gt;

&lt;p&gt;显然，信息增益更大的特征具有更强的分类能力。但信息增益的值很大程度上依赖于数据集的信息熵$H(Y)$，因而并不具有绝对意义。为解决这一问题，研究者又提出了信息增益比的概念，并将其定义为$g(X,Y)=I(X;Y)/H(Y)$。&lt;/p&gt;

&lt;p&gt;在机器学习中经常使用的信息论概念叫作&lt;code&gt;Kullback-Leibler散度&lt;/code&gt;，简称&lt;code&gt;KL散度&lt;/code&gt;。KL散度是描述两个概率分布$P$和$Q$之间的差异的一种方法，其定义为\(D_{KL}​(P∣∣Q)=\sum_{i=1}^n​p(x_i​)\log_2\frac{p(x_i​)}{​q(x_i​)}\)​&lt;/p&gt;

&lt;p&gt;信息论中还有一个重要定理，叫作“最大熵原理”。&lt;code&gt;最大熵原理&lt;/code&gt;是确定随机变量统计特性时力图最符合客观情况的一种准则。对于一个未知的概率分布，最坏的情况就是它以等可能性取到每个可能的取值。这个时候的概率分布最均匀，也就是随机变量的随机程度最高，对它进行预测也就最困难。&lt;/p&gt;

&lt;p&gt;将最大熵原理应用到分类问题上就可以得到&lt;code&gt;最大熵模型&lt;/code&gt;。在分类问题中，首先要确定若干特征函数作为分类的依据。为了保证特征函数的有效性，其在模型真实分布$P(X)$上的数学期望和在由训练数据集推导出的经验分布$\widetilde{P}(X)$上的数学期望应该相等，即对给定特征函数数学期望的估计应该是个无偏估计量。&lt;/p&gt;

&lt;p&gt;这样一来，每一个特征函数就对应了一个约束条件。分类的任务就是在这些约束条件下，确定一个最好的分类模型。由于除了这些约束条件之外，没有任何关于分类的先验知识，因而需要利用最大熵原理，求解出不确定性最大的条件分布，即让以下函数的取值最大化\(H(p)=−\sum_{x,y}\widetilde{p}​(x)p(y∣x)\log_2​p(y∣x)\)
式中的$p(y∣x)$就是分类问题要确定的目标条件分布。计算上式的最大值实质上就是一个约束优化问题，由特征函数确定的约束条件可以通过&lt;code&gt;拉格朗日乘子&lt;/code&gt;的引入去除其影响，转化为无约束优化问题。从数学上可以证明，这个模型的解是存在且唯一的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210816.jpg&quot; alt=&quot;宝贝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E4%BF%A1%E6%81%AF%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E4%BF%A1%E6%81%AF%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>信息论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-最优化理论</title>
        <description>&lt;p&gt;人工智能的目标是最优化：在复杂环境和多体交互中做出最优决策。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;最优化理论&lt;/code&gt;研究的问题是给定的&lt;code&gt;目标函数&lt;/code&gt;的最大值（最小值）是否存在，并找到令目标函数取到最大值（最小值）的数值。
如果把给定的目标函数看成连绵的山脉，最优化的过程就是判断顶峰的位置并找到到达顶峰路径的过程。
大多数最优化问题都可以通过使目标函数$f(x)$最小化解决，最大化问题则可以通过最小化$−f(x)$实现。
在人工智能和深度学习的应用场景下，只要目标函数的取值足够小，就可以把这个值当作全局最小值使用，作为对性能和复杂度的折中。&lt;/p&gt;

&lt;p&gt;根据约束条件的不同，最优化问题可以分为&lt;code&gt;无约束优化&lt;/code&gt;和&lt;code&gt;约束优化&lt;/code&gt;两类。无约束优化对自变量 x 的取值没有限制，约束优化则把 x 的取值限制在特定的集合内，也就是满足一定的约束条件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;线性规划&lt;/code&gt;就是一类典型的约束优化，其解决的问题通常是在有限的成本约束下取得最大的收益。约束优化问题通常比无约束优化问题更加复杂，但通过拉格朗日乘子的引入可以将含有$n$个变量和$k$个约束条件的问题转化为含有$(n+k)$个变量的无约束优化问题。&lt;/p&gt;

&lt;p&gt;求解无约束优化问题最常用的方法是&lt;code&gt;梯度下降法&lt;/code&gt;。直观地说，梯度下降法就是沿着目标函数值下降最快的方向寻找最小值，就像爬山时要沿着坡度最陡的路径寻找山顶一样。在数学上，梯度的方向是目标函数导数的反方向。&lt;/p&gt;

&lt;p&gt;如果将二阶导数引入优化过程，得到的典型方法就是牛顿法。在牛顿法中，目标函数首先被泰勒展开，写成二阶近似的形式（相比之下，梯度下降法只保留了目标函数的一阶近似）。此时再对二阶近似后的目标函数求导，并令其导数等于 0，得到的向量表示的就是下降最快的方向。相比于梯度下降法，牛顿法的收敛速度更快。&lt;/p&gt;

&lt;p&gt;不管是利用一阶导数的梯度下降法，还是利用二阶导数的牛顿法，其寻找最小值点的基本思想都是先确定方向，再确定步长，因而统称为&lt;code&gt;线性搜索方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有一类算法，其寻找最小值点的基本思路是先确定步长，以步长为参数划定一个区域，再在这个区域内寻找最快下降的方向。这类算法被称为&lt;code&gt;置信域方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;相对于传统的基于数学理论的最优化方法，启发式算法显得返璞归真。启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。&lt;/p&gt;

&lt;p&gt;启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。事实上，搜索越多并不意味着智能越高，智能高的表现恰恰是能够善用启发式策略，不用经过大量搜索也能解决问题。启发式算法的实例包括模拟生物进化规律的遗传算法、模拟统计物理中固体结晶过程的模拟退火算法、模拟低等动物产生集群智能的蚁群算法等。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210814.jpg&quot; alt=&quot;宝贝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>最优化理论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-数理统计</title>
        <description>&lt;p&gt;&lt;code&gt;数理统计&lt;/code&gt;根据实验或观察得到的数据来研究随机现象，并对研究对象的客观规律做出合理的估计和判断。&lt;/p&gt;

&lt;p&gt;在数理统计中，可用的资源是有限的数据集合，这个有限的数据集合称为&lt;code&gt;样本&lt;/code&gt;。
相应的，观察对象的所有取值被称为&lt;code&gt;总体&lt;/code&gt;。数理统计的任务就是
根据样本推断总体的数字特征。&lt;/p&gt;

&lt;p&gt;推断的工具是统计量，统计量是样本的函数，是个随机变量。两个最重要的统计量是&lt;code&gt;样本均值&lt;/code&gt;和&lt;code&gt;样本方差&lt;/code&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;样本均值：$\overline{X} = \frac{1}{n}\sum_{i=1}^nX_i$&lt;/li&gt;
  &lt;li&gt;样本方差：$S^2 = \frac{1}{n-1}\sum_{i=1}^n(X_i-\overline{X})^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;统计推断的基本问题分为两大类：&lt;code&gt;参数估计&lt;/code&gt;和&lt;code&gt;假设检验&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数估计通过随机抽取样本来估计部分分布的未知参数，包括点估计和区间估计&lt;/p&gt;

&lt;p&gt;假设检验通过随机抽取样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210813.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 13 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1</guid>
        
        
        <category>AI</category>
        
        <category>数理统计</category>
        
      </item>
    
      <item>
        <title>AI数学基础-概率论</title>
        <description>&lt;p&gt;同线性代数一样，概率论也代表了一种看待世界的方式，&lt;code&gt;其关注的焦点是无处不在的可能性&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;频率学派&quot;&gt;频率学派&lt;/h2&gt;

&lt;p&gt;从事件发生的频率认识概率的方法被称为“频率学派”（frequentist probability），“概率”，其实是一个可独立重复的随机实验中单个结果出现频率的极限。在概率的定量计算上，频率学派依赖的基础是古典概率模型。假设所有基本事件的数目为 n，待观察的随机事件 A 中包含的基本事件数目为 k，则古典概率模型下事件概率的计算公式为&lt;/p&gt;

&lt;p&gt;$P(A) = \frac{k}{n}$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;条件概率&lt;/code&gt;是根据已有信息对样本空间进行调整后得到的新的概率分布。假定有两个随机事件 A 和 B，条件概率就是指事件 A 在事件 B 已经发生的条件下发生的概率，用以下公式表示&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A&lt;/td&gt;
      &lt;td&gt;B) = \frac{P(AB)}{P(B)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(AB)$称为&lt;code&gt;联合概率&lt;/code&gt;，表示的是 A 和 B 两个事件共同发生的概率。如果联合概率等于两个事件各自概率的乘积，即$P(AB) = P(A)*P(B)$，说明这两个事件的发生互不影响，即两者相互独立。&lt;/p&gt;

&lt;p&gt;基于条件概率可以得出&lt;code&gt;全概率公式&lt;/code&gt;。全概率公式的作用在于将复杂事件的概率求解转化为在不同情况下发生的简单事件的概率求和，即&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A) = \sum_{i=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$\sum_{i=1}^NP(B_i) = 1$&lt;/p&gt;

&lt;p&gt;全概率公式代表了频率学派解决概率问题的思路，即先做出一些假设$P(B_i​)$，再在这些假设下讨论随机事件的概率$P(A∣B_i​)$。&lt;/p&gt;

&lt;h2 id=&quot;贝叶斯学派&quot;&gt;贝叶斯学派&lt;/h2&gt;

&lt;p&gt;对全概率公式稍作整理，就演化出了求解“逆概率”这一重要问题。所谓“逆概率”解决的是在事件结果已经确定的条件下$P(A)$，推断各种假设发生的可能性$P(B_i​∣A)$。其通用的公式形式被称为贝叶斯公式：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(B_i&lt;/td&gt;
      &lt;td&gt;A) = \frac{P(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)}{\sum_{j=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_j)*P(B_j)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;贝叶斯公式可以进一步抽象为贝叶斯定理：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(H&lt;/td&gt;
      &lt;td&gt;D) = \frac{P(D&lt;/td&gt;
      &lt;td&gt;H)*P(H)}{P(D)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(H)$被称为&lt;code&gt;先验概率&lt;/code&gt;，即预先设定的假设成立的概率；$P(D∣H)$被称为&lt;code&gt;似然概率&lt;/code&gt;，是在假设成立的前提下观测到结果的概率；$P(H∣D)$被称为&lt;code&gt;后验概率&lt;/code&gt;，即在观测到结果的前提下假设成立的概率。&lt;/p&gt;

&lt;p&gt;贝叶斯定理提供了一种全新的逻辑。它根据观测结果寻找合理的假设，或者说根据观测数据寻找最佳的理论解释，其关注的焦点在于后验概率。概率论的&lt;code&gt;贝叶斯学派&lt;/code&gt;正是诞生于这种理念。&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;p&gt;频率学派认为假设是客观存在且不会改变的，即存在固定的先验分布，只是作为观察者的我们无从知晓。因而在计算具体事件的概率时，要先确定概率分布的类型和参数，以此为基础进行概率推演。相比之下，贝叶斯学派则认为固定的先验分布是不存在的，参数本身也是随机数。换言之，假设本身取决于观察结果，是不确定并且可以修正的。数据的作用就是对假设做出不断的修正，使观察者对概率的主观认识更加接近客观实际。&lt;/p&gt;

&lt;p&gt;概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。&lt;/p&gt;

&lt;p&gt;概率的估计有两种方法：&lt;code&gt;最大似然估计法&lt;/code&gt;和&lt;code&gt;最大后验概率法&lt;/code&gt;，两者分别体现出频率学派和贝叶斯学派对概率的理解方式。最大似然估计法的思想是使训练数据出现的概率最大化，依此确定概率分布中的未知参数，估计出的概率分布也就最符合训练数据的分布。最大后验概率法的思想则是根据训练数据和已知的其他条件，使未知参数出现的可能性最大化，并选取最可能的未知参数取值作为估计值。在估计参数时，最大似然估计法只需要使用训练数据，最大后验概率法除了数据外还需要额外的信息，就是贝叶斯公式中的先验概率。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;概率论关注的是生活中的不确定性或可能性&lt;/li&gt;
  &lt;li&gt;频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算&lt;/li&gt;
  &lt;li&gt;贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210809.jpg&quot; alt=&quot;M&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>概率论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(2)</title>
        <description>&lt;h2 id=&quot;线性空间&quot;&gt;线性空间&lt;/h2&gt;

&lt;p&gt;一个集合，它的元素是具有相同维数的向量，并且定义了加法和数乘结构化运算，这样的集合就被称为&lt;code&gt;线性空间&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;内积空间&quot;&gt;内积空间&lt;/h2&gt;

&lt;p&gt;定义了内积运算的线性空间被称为&lt;code&gt;内积空间&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;内积空间中，一组两两正交的向量构成这个空间的&lt;code&gt;正交基&lt;/code&gt;，若正交基中基向量的$L^2$范数都是单位长度 1，这组正交基就是&lt;code&gt;标准正交基&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;矩阵&quot;&gt;矩阵&lt;/h2&gt;

&lt;p&gt;线性空间点的变化对应着向量的线性变换，而描述对象变化抑或向量变化的语言，正是矩阵&lt;/p&gt;

&lt;p&gt;线性空间中变化的实现有两种方式：一是点本身的变化，二是参考系的变化。
在第一种方式中，使某个点发生变化的方法是用代表变化的矩阵乘以代表对象的向量。而对坐标系施加变换的方法，就是让表示原始坐标系的矩阵与表示变换的矩阵相乘。&lt;/p&gt;

&lt;p&gt;描述矩阵的一对重要参数是&lt;code&gt;特征值&lt;/code&gt;和&lt;code&gt;特征向量&lt;/code&gt;。对于给定的矩阵$A$，假设其特征值为$\lambda$，特征向量为$\vec x$，则它们的关系如下：&lt;/p&gt;

&lt;p&gt;$A\vec x = \lambda\vec x$&lt;/p&gt;

&lt;p&gt;矩阵代表了向量的变换，其效果通常是对原始向量同时施加方向变化和尺度变化。可对于有些特殊的向量，矩阵的作用只有尺度变化而没有方向变化，也就是只有伸缩的效果而没有旋转的效果。对于给定的矩阵来说，这类特殊的向量就是矩阵的特征向量，特征向量的尺度变化系数就是特征值。&lt;/p&gt;

&lt;p&gt;求解给定矩阵的特征值和特征向量的过程叫做特征值分解，但能够进行特征值分解的矩阵必须是 n 维方阵。将特征值分解算法推广到所有矩阵之上，就是更加通用的奇异值分解。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性&lt;/li&gt;
  &lt;li&gt;向量的实质是 n 维线性空间中静止的点&lt;/li&gt;
  &lt;li&gt;线性变换描述向量或作为参考系的坐标的变化，可以用矩阵表示&lt;/li&gt;
  &lt;li&gt;矩阵的特征值和特征向量描述了变化的速度和方向&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210808.jpg&quot; alt=&quot;宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 08 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</guid>
        
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(1)</title>
        <description>&lt;h2 id=&quot;人工智能理解&quot;&gt;人工智能理解&lt;/h2&gt;

&lt;p&gt;建立在以线性代数和概率论为骨架的基础数学上，通过简单的模型组合实现复杂的功能。&lt;/p&gt;

&lt;h2 id=&quot;线性代数的核心意义&quot;&gt;线性代数的核心意义&lt;/h2&gt;

&lt;p&gt;万事万物都可以被抽象成某些特征的组合，并在由预置规则定义的框架之下以静态和动态的方式加以观察。&lt;/p&gt;

&lt;p&gt;用虚拟数字世界表示真实物理世界的工具。&lt;/p&gt;

&lt;h2 id=&quot;线性代数基本概念&quot;&gt;线性代数基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;集合(set)：某些特定对象汇总成的集体&lt;/li&gt;
  &lt;li&gt;标量(scalar)：单独数&lt;code&gt;a&lt;/code&gt;构成的元素，&lt;code&gt;a&lt;/code&gt;可以是&lt;code&gt;整数&lt;/code&gt;、&lt;code&gt;实数&lt;/code&gt;或&lt;code&gt;复数&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量(vector)：多个标量按一定顺序组成一个序列&lt;/p&gt;

    &lt;p&gt;向量可以看作标量的扩展，原始的数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一确定向量中的元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;矩阵(matrix)：交向量的所有标量都替换成同规格的向量&lt;/p&gt;

    &lt;p&gt;相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要两个索引确定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;张量(tensor)：将矩阵中的每个标量再替换为向量，得到的就是张量。张量就是高阶矩阵&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;描述向量的数学语言&quot;&gt;描述向量的数学语言&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;范数(norm)：对单个向量大小的度量，描述的是向量自身的性质，其作用是将向量映射为一个非负的数值。通用$L^p 范数定义如下：&lt;/p&gt;

    &lt;p&gt;$∣\vec x∣_p​ = (\sum_i∣x_i​∣^p)^\frac{1}{p}$​&lt;/p&gt;

    &lt;p&gt;对于一个给定的向量，$L^1$范数计算的是向量所有元素绝对值的和，$L^2$范数计算的是通常意义的向量长度，$L^\infty$范数计算的则是向量中最大元素的取值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内积(inner product)：计算的是两个向量的关系。两个同维向量内积的表达式为&lt;/p&gt;

    &lt;p&gt;$&amp;lt;\vec x, \vec y&amp;gt; = \sum_ix_i*y_i$&lt;/p&gt;

    &lt;p&gt;即对应元素乘积的求和。内积能表示两个向量的相对位置，即向量之间的夹角。一种特殊的情况是内积是 0，即$&amp;lt;\vec x, \vec y&amp;gt; = 0$，在二维空间上，这意味着两个向量夹角 90 度，即相互垂直。而在高维空间上，这咱关系被称为&lt;code&gt;正交(orthogonality)&lt;/code&gt;。如果两个向量正交，说明它们线性无关，相互独立，互不影响。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
</description>
        <pubDate>Sat, 07 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</guid>
        
        
        <category>AI</category>
        
        <category>线性代数</category>
        
      </item>
    
      <item>
        <title>Git Add</title>
        <description>&lt;p&gt;Add a folder to git with exceptions&lt;/p&gt;

&lt;p&gt;Given this folder structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
├── bin
│  └── parse-ansi-codes.rs
├── Cargo.lock
├── Cargo.toml
├── README.md
├── src
│  ├── cursor.rs
│  ├── lib.rs
│  └── style.rs
├── target
│  └── debug
└── test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can add the entire &lt;code&gt;app&lt;/code&gt; directory to git, while ignoring the bin folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add . ':!bin'
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210805.jpg&quot; alt=&quot;宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/git_add_with_exceptions</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_add_with_exceptions</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>Git Proxy</title>
        <description>&lt;h2 id=&quot;http-代理&quot;&gt;HTTP 代理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git config --global http.proxy 127.0.0.1:1080
git config --global https.proxy 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ssh-代理&quot;&gt;SSH 代理&lt;/h2&gt;

&lt;p&gt;SSH 代理需要在密钥目录&lt;code&gt;~/.ssh&lt;/code&gt;(Windows 下是&lt;code&gt;C:\Users\{UserName}\.ssh&lt;/code&gt;)新建一个&lt;code&gt;config&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cat ~/.ssh/config
Host github.com
    ProxyCommand connect -S 127.0.0.1:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210803.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/git_proxy</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_proxy</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>VS Code的使用</title>
        <description>&lt;h2 id=&quot;vs-code-快捷键&quot;&gt;VS Code 快捷键&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标移动&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;方向键&lt;/code&gt;: 在&lt;strong&gt;单个字符&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + 左右方向键&lt;/code&gt;): 在&lt;strong&gt;单词&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Home/End&lt;/code&gt;): 把光标移动到行首或者行末&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + Shift + \&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Shift + \&lt;/code&gt;): 光标在&lt;strong&gt;代码块&lt;/strong&gt;的始末跳转&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 上下方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Home/End&lt;/code&gt;): 光标移动到文档的第一行或者最后一行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本选择&lt;/p&gt;

    &lt;p&gt;只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除整行(剪切 Cmd+X 也可用于删除整行)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行下面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行上面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上复制&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下复制&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义快捷键&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;Cmd+K, Cmd+S&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl+K, Ctrl+S&lt;/code&gt;)打开”Keyboard Shortcuts”窗口修改&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Backspace&lt;/code&gt; 删除光标之前的整行内容(Delete All Left)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Delete&lt;/code&gt; 删除光标之后的整行内容(Delete All Right)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Shift + ]&lt;/code&gt; 选择括号内所有内容(Select to Bracket)&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + U&lt;/code&gt; Transform to Uppercase&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + L&lt;/code&gt; Transform to Lowercase&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20191012.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Oct 2019 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/VSCode</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/VSCode</guid>
        
        
        <category>vscode</category>
        
        <category>editor</category>
        
      </item>
    
  </channel>
</rss>
