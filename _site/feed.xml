<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 10 May 2018 10:00:27 +0800</pubDate>
    <lastBuildDate>Thu, 10 May 2018 10:00:27 +0800</lastBuildDate>
    <generator>Jekyll v3.8.0</generator>
    
      <item>
        <title>coincoin源码之token</title>
        <description>&lt;h2 id=&quot;区块链是什么&quot;&gt;区块链是什么&lt;/h2&gt;

&lt;p&gt;区块链是一个提供了拜占庭容错、并保证了最终一致性的分布式数据库；从数据结构上看，它是基于时间序列的链式数据块结构；从节点拓扑上看，它所有的节点互为冗余备份；从操作上看，它提供了基于密码学的公私钥管理体系来管理账户。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;区块链是一个分布式网络；&lt;/li&gt;
  &lt;li&gt;区块链可以帮助多个节点达成共识去记录和 Token 相关的事情；&lt;/li&gt;
  &lt;li&gt;区块链可以帮助所有人无门槛地构建属于自己的小经济系统。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;区块链在技术上的-7-个特征&quot;&gt;区块链在技术上的 7 个特征&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;区块链的存储基于分布式数据库；&lt;/li&gt;
  &lt;li&gt;数据库是区块链的数据载体，区块链是交易的业务逻辑载体；&lt;/li&gt;
  &lt;li&gt;区块链按时间序列化区块数据，整个网络有一个最终确定状态；&lt;/li&gt;
  &lt;li&gt;区块链只对添加有效，对其他操作无效；&lt;/li&gt;
  &lt;li&gt;交易基于非对称加密的公私钥验证；&lt;/li&gt;
  &lt;li&gt;区块链网络要求拜占庭将军容错；&lt;/li&gt;
  &lt;li&gt;共识算法能够“解决”双花问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;coincoin之tokenblockchain-app&quot;&gt;coincoin之token，blockchain app&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/coincoin_token.jpg&quot; alt=&quot;token&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180510.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 10 May 2018 00:00:00 +0800</pubDate>
        <link>/blockchain_coincoin</link>
        <guid isPermaLink="true">/blockchain_coincoin</guid>
        
        
        <category>elixir</category>
        
        <category>blockchain</category>
        
      </item>
    
      <item>
        <title>Elixir String Manipulation</title>
        <description>&lt;p&gt;To get the list of string that compose a longer string, use String.codepoints/1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex(1)&amp;gt; String.codepoints(&quot;你好a&quot;)
[&quot;你&quot;, &quot;好&quot;, &quot;a&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To get the list of codepoints that represent each letter in the string, use String.to_charlist/1&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex(2)&amp;gt; String.to_charlist(&quot;你好a&quot;)
[20320, 22909, 97]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180505.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 00:00:00 +0800</pubDate>
        <link>/elixir_today_i_learned</link>
        <guid isPermaLink="true">/elixir_today_i_learned</guid>
        
        
        <category>elixir</category>
        
      </item>
    
      <item>
        <title>Elixir - with</title>
        <description>&lt;h2 id=&quot;macrowithargs&quot;&gt;&lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt;macrowith(args)&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Used to combine matching clauses.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iex&amp;gt; opts = %{width: 10, height: 15}
iex&amp;gt; with {:ok, width} &amp;lt;- Map.fetch(opts, :width),
...&amp;gt;      {:ok, height} &amp;lt;- Map.fetch(opts, :height),
...&amp;gt;      do: {:ok, width * height}
{:ok, 150}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If all clauses match, the &lt;code&gt;do&lt;/code&gt; block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned.&lt;/p&gt;

&lt;p&gt;Guards can be used in patterns as well:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iex&amp;gt; users = %{&quot;melany&quot; =&amp;gt; &quot;guest&quot;, &quot;bob&quot; =&amp;gt; :admin}
iex&amp;gt; with {:ok, role} when not is_binary(role) &amp;lt;- Map.fetch(users, &quot;bob&quot;),
...&amp;gt;      do: {:ok, to_string(role)}
{:ok, &quot;admin&quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180504.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 04 May 2018 00:00:00 +0800</pubDate>
        <link>/elixir_today_i_learned</link>
        <guid isPermaLink="true">/elixir_today_i_learned</guid>
        
        
        <category>elixir</category>
        
      </item>
    
      <item>
        <title>Flexible Box Layout</title>
        <description>&lt;h2 id=&quot;flex-layout-overview&quot;&gt;Flex Layout Overview&lt;/h2&gt;

&lt;p&gt;Flex layout is designed for laying out more complex applications and webpages.The contents of a flex container:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;can be laid out in any flow direction (leftwards, rightwards, downwards, or even upwards!)&lt;/li&gt;
  &lt;li&gt;can have their display order reversed or rearranged at the style layer (i.e., visual order can be independent of source and speech order)&lt;/li&gt;
  &lt;li&gt;can be laid out linearly along a single (main) axis or wrapped into multiple lines along a secondary (cross) axis&lt;/li&gt;
  &lt;li&gt;can “flex” their sizes to respond to the available space&lt;/li&gt;
  &lt;li&gt;can be aligned with respect to their container or each other on the secondary (cross)&lt;/li&gt;
  &lt;li&gt;can be dynamically collapsed or uncollapsed along the main axis while preserving the container’s cross size&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;开始使用flexlayout&quot;&gt;开始使用FlexLayout&lt;/h2&gt;

&lt;p&gt;在父元素中显式的设置&lt;code&gt;display:flex&lt;/code&gt;或者&lt;code&gt;display:inline-flex&lt;/code&gt;就会自动变成Flex容器，而其子元素就变成了Flex项目。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Flex容器（&lt;code&gt;Flex Container&lt;/code&gt;）：父元素显式设置了&lt;code&gt;display:flex&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Flex项目（&lt;code&gt;Flex Items&lt;/code&gt;）：Flex容器内的子元素&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;flex容器属性&quot;&gt;Flex容器属性&lt;/h2&gt;

&lt;h3 id=&quot;flex-direction&quot;&gt;flex-direction&lt;/h3&gt;
&lt;p&gt;flex-direction属性控制Flex项目沿着主轴（&lt;code&gt;Main Axis&lt;/code&gt;）的排列方向。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;/* ul 是一个flex容器 */
ul {
    flex-direction: row || column || row-reverse || column-reverse;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;简单点来说，就是&lt;code&gt;flex-direction&lt;/code&gt;属性让你决定Flex项目如何排列。它可以是行（水平）、列（垂直）或者行和列的反向。
从技术上讲，水平和垂直在Flex世界中不是什么方向（概念）。它们常常被称为主轴（&lt;code&gt;Main-Axis&lt;/code&gt;）和侧轴（&lt;code&gt;Cross-Axis&lt;/code&gt;）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/understanding-flexbox-11.jpg&quot; alt=&quot;flex-direction&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;flex-wrap&quot;&gt;flex-wrap&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul { flex-wrap: wrap || nowrap || wrap-reverse; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;flex-flow&quot;&gt;flex-flow&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-flow&lt;/code&gt;是&lt;code&gt;flex-direction&lt;/code&gt;和&lt;code&gt;flex-wrap&lt;/code&gt;两个属性的速记属性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul { flex-flow: row wrap; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;justify-content&quot;&gt;justify-content&lt;/h3&gt;
&lt;p&gt;决定Flex项在&lt;code&gt;Main-Axis&lt;/code&gt;上的排列方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul { justify-content: flex-start || flex-end || center || space-between || space-around }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;默认&lt;code&gt;flex-start&lt;/code&gt;让所有Flex项目靠Main-Axis开始边缘（左对齐）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;让所有Flex项目靠Main-Axis结束边缘（右对齐）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;center&lt;/code&gt;让所有Flex项目排在Main-Axis中间（居中对齐）&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;space-between&lt;/code&gt;让除了第一个和最一个Flex项目的两者间间距相同（两端对齐）
&lt;img src=&quot;/imgs/understanding-flexbox-24.jpeg&quot; alt=&quot;flex-direction&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code&gt;space-around&lt;/code&gt;让每个Flex项目具有相同的空间
&lt;img src=&quot;/imgs/understanding-flexbox-26.jpeg&quot; alt=&quot;flex-direction&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;align-items&quot;&gt;align-items&lt;/h3&gt;
&lt;p&gt;决定Flex项在&lt;code&gt;Cross-Axis&lt;/code&gt;上的排列方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;ul { align-items: flex-start || flex-end || center || stretch || baseline }
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;默认&lt;code&gt;stretch&lt;/code&gt;让所有的Flex项目高度和Flex容器高度一样&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;flex-start&lt;/code&gt;让所有Flex项目靠Cross-Axis开始边缘（顶部对齐）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;flex-end&lt;/code&gt;让所有Flex项目靠Cross-Axis结束边缘（底部对齐）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;center&lt;/code&gt;让Flex项目在Cross-Axis中间（居中对齐）&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;baseline&lt;/code&gt;让所有Flex项目在Cross-Axis上沿着他们自己的基线对齐&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;align-content&quot;&gt;align-content&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;align-content&lt;/code&gt;属性用于多行的Flex容器。它也是用来控制Flex项目在Flex容器里的排列方式，排列效果和&lt;code&gt;align-items&lt;/code&gt;值一样，但没有baseline属性值。&lt;/p&gt;

&lt;h2 id=&quot;flex项目属性&quot;&gt;Flex项目属性&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;order || flex-grow || flex-shrink || flex-basis
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;order&quot;&gt;order&lt;/h3&gt;
&lt;p&gt;允许Flex项目在一个Flex容器中重新排序。&lt;code&gt;order&lt;/code&gt;属性的默认值是0。它可以接受一个正值，也可以接受一个负值。Flex项目会根据&lt;code&gt;order&lt;/code&gt;值重新排序。从底到高。&lt;/p&gt;

&lt;h3 id=&quot;flex-grow-和-flex-shrink&quot;&gt;flex-grow 和 flex-shrink&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-grow&lt;/code&gt;和&lt;code&gt;flex-shrink&lt;/code&gt;属性控制Flex项目在容器有多余的空间如何放大（扩展），在没有额外空间又如何缩小。
他们可能接受0或者大于0的任何正数。
默认情况下，&lt;code&gt;flex-grow&lt;/code&gt;属性值设置为0。表示Flex项目不会增长，填充Flex容器可用空间。
&lt;code&gt;flex-shrink&lt;/code&gt;的值是1，也就是说空间缩小Flex项目也会缩小，以适应新的空间。&lt;/p&gt;

&lt;h3 id=&quot;flex-basis&quot;&gt;flex-basis&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex-basis&lt;/code&gt;属性可以指定Flex项目的初始大小。也就是&lt;code&gt;flex-grow&lt;/code&gt;和&lt;code&gt;flex-shrink&lt;/code&gt;属性调整它的大小以适应Flex容器之前。
默认的值是&lt;code&gt;auto&lt;/code&gt;。&lt;code&gt;flex-basis&lt;/code&gt;可以取任何用于&lt;code&gt;width&lt;/code&gt;属性的任何值。比如 &lt;code&gt;% || em || rem || px&lt;/code&gt;等。&lt;/p&gt;

&lt;h3 id=&quot;flex速记&quot;&gt;flex速记&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;flex&lt;/code&gt;是&lt;code&gt;flex-grow&lt;/code&gt;、&lt;code&gt;flex-shrink&lt;/code&gt;和&lt;code&gt;flex-basis&lt;/code&gt;三个属性的速记（简写）&lt;/p&gt;

&lt;h3 id=&quot;align-self&quot;&gt;align-self&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;auto || flex-start || flex-end || center || baseline || stretch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;与Flex容器的&lt;code&gt;align-items&lt;/code&gt;属性类似，只不过只改变本Flex项目沿着侧轴的位置。&lt;/p&gt;

&lt;h2 id=&quot;绝对和相对flex项目&quot;&gt;绝对和相对Flex项目&lt;/h2&gt;
&lt;p&gt;绝对Flex项目的宽度只基于 flex 属性，而相对Flex项目的宽度基于内容大小。
当Flex项目因为被设置为&lt;code&gt;flex-basis: auto&lt;/code&gt;，而导致宽度被自动计算时，是基于Flex项目内包含的内容的大小而计算。
Flex项目的初始宽度是零&lt;code&gt;flex-basis: 0&lt;/code&gt;，并且它们会伸展以适应可用空间。当有两到多个Flex项目的&lt;code&gt;flex-basis&lt;/code&gt;取值为0时，它们会基于&lt;code&gt;flex-grow&lt;/code&gt;值共享可用空间。&lt;/p&gt;

&lt;h2 id=&quot;auto-margin对齐&quot;&gt;Auto-margin对齐&lt;/h2&gt;
&lt;p&gt;当心Flex项目上的&lt;code&gt;margin: auto&lt;/code&gt;对齐。值为&lt;code&gt;auto&lt;/code&gt;的方向（左、右或者二者都是）会占据所有剩余空间。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180503.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 03 May 2018 00:00:00 +0800</pubDate>
        <link>/ife_flex</link>
        <guid isPermaLink="true">/ife_flex</guid>
        
        
        <category>front-end</category>
        
        <category>html</category>
        
        <category>ife</category>
        
      </item>
    
      <item>
        <title>ife layout: 三栏网页宽度自适应布局方法</title>
        <description>&lt;h2 id=&quot;绝对定位法&quot;&gt;绝对定位法&lt;/h2&gt;

&lt;p&gt;最直观，最容易理解：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右&lt;code&gt;margin&lt;/code&gt;值撑开距离。于是实现了三栏自适应布局。&lt;/p&gt;

&lt;h2 id=&quot;margin负值法&quot;&gt;margin负值法&lt;/h2&gt;

&lt;p&gt;中间的主体要使用双层标签。外层&lt;code&gt;div&lt;/code&gt;宽度100%显示，并且浮动（本例左浮动，下面所述依次为基础），内层&lt;code&gt;div&lt;/code&gt;为真正的主体内容，含有左右210像素的&lt;code&gt;margin&lt;/code&gt;值。左栏与右栏都是采用&lt;code&gt;margin&lt;/code&gt;负值定位的，左栏左浮动，&lt;code&gt;margin-left&lt;/code&gt;为-100%，由于前面的&lt;code&gt;div&lt;/code&gt;宽度100%与浏览器，所以这里的-100% &lt;code&gt;margin&lt;/code&gt;值正好使左栏div定位到了页面的左侧；右侧栏也是左浮动，其&lt;code&gt;margin-left&lt;/code&gt;也是负值，大小为其本身的宽度即200像素。
注意几个&lt;code&gt;div&lt;/code&gt;的顺序，无论是左浮动还是右浮动，先是主体部分&lt;code&gt;div&lt;/code&gt;，然后是左右两栏。&lt;/p&gt;

&lt;h2 id=&quot;自身浮动法&quot;&gt;自身浮动法&lt;/h2&gt;

&lt;p&gt;左栏左浮动，右栏右浮动，主体直接放后面，就实现了自适应。
三个&lt;code&gt;div&lt;/code&gt;标签的顺序的关键是要把主体div放在最后，左右两栏&lt;code&gt;div&lt;/code&gt;顺序任意。&lt;/p&gt;

&lt;h2 id=&quot;flex&quot;&gt;Flex&lt;/h2&gt;

&lt;p&gt;两侧&lt;code&gt;flex: 0 0 auto;&lt;/code&gt;，主体&lt;code&gt;flex: 1 1 auto;&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180502.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 02 May 2018 00:00:00 +0800</pubDate>
        <link>/ife_layout</link>
        <guid isPermaLink="true">/ife_layout</guid>
        
        
        <category>front-end</category>
        
        <category>html</category>
        
        <category>ife</category>
        
      </item>
    
      <item>
        <title>Docker getting started</title>
        <description>&lt;h2 id=&quot;一认识docker&quot;&gt;一、认识Docker&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/containers-vms-together.png&quot; alt=&quot;Docker&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二install-docker-ce&quot;&gt;二、Install Docker-CE&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Linux以&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/centos/&quot;&gt;Centos&lt;/a&gt;为例
    &lt;pre&gt;&lt;code&gt; #Centos7
 yum install -y yum-utils device-mapper-persistent-data lvm2
 yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
 yum install docker-ce

 #Centos6
 rpm -iUvh http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
 yum install docker-io

 镜像加速
 /etc/docker/daemon.json
 {
     &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]
 }
 service docker start

 查看Docker版本
 docker -v
 docker run hello-world
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://store.docker.com/editions/community/docker-ce-desktop-mac&quot;&gt;macOS&lt;/a&gt;
    &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt; brew install docker
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://store.docker.com/editions/community/docker-ce-desktop-windows&quot;&gt;Windows&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三容器运行第1个程序&quot;&gt;三、容器，运行第1个程序&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Dockerfile
    &lt;pre&gt;&lt;code&gt;  # 将官方 Python 运行时用作父镜像
  FROM python:2.7-slim

  # 将工作目录设置为 /app
  WORKDIR /app

  # 将当前目录内容复制到位于 /app 中的容器中
  ADD . /app

  # 安装 requirements.txt 中指定的任何所需软件包
  RUN pip install -r requirements.txt

  # 使端口 80 可供此容器外的环境使用
  EXPOSE 80

  # 定义环境变量
  ENV NAME World

  # 在容器启动时运行 app.py
  CMD [&quot;python&quot;, &quot;app.py&quot;]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;requirements.txt
    &lt;pre&gt;&lt;code&gt;  Flask
  Redis
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;app.py
    &lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;  from flask import Flask
  from redis import Redis, RedisError
  import os
  import socket

  # Connect to Redis
  redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)

  app = Flask(__name__)

  @app.route(&quot;/&quot;)
  def hello():
      try:
          visits = redis.incr(&quot;counter&quot;)
      except RedisError:
          visits = &quot;&amp;lt;i&amp;gt;cannot connect to Redis, counter disabled&amp;lt;/i&amp;gt;&quot;

      html = &quot;&amp;lt;h3&amp;gt;Hello {name}!&amp;lt;/h3&amp;gt;&quot; \
          &quot;&amp;lt;b&amp;gt;Hostname:&amp;lt;/b&amp;gt; {hostname}&amp;lt;br/&amp;gt;&quot; \
          &quot;&amp;lt;b&amp;gt;Visits:&amp;lt;/b&amp;gt; {visits}&quot;
      return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)

  if __name__ == &quot;__main__&quot;:
      app.run(host='0.0.0.0', port=80)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;构建运行
    &lt;pre&gt;&lt;code&gt;  docker build -t hello_docker .
  docker images
REPOSITORY              TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
hello_docker            latest              940a583806b0        4 minutes ago       155.6 MB

  docker run -p 888:80 hello_docker
后台运行
  docker run -d -p 888:80 hello_docker
  docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                 NAMES
73e81f97609c        hello_docker        &quot;python app.py&quot;     57 seconds ago      Up 56 seconds       0.0.0.0:888-&amp;gt;80/tcp   gloomy_tesla
  docker stop 73e81f97609c
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;共享镜像
    &lt;pre&gt;&lt;code&gt;  docker login
  docker tag hello_docker raina7325/get-started:part1
  docker push raina7325/get-started:part1
  docker run -p 8888:80 raina7325/get-started:part1
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;常用命令
    &lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;  docker build -t friendlyname .# 使用此目录的 Dockerfile 创建镜像
  docker run -p 4000:80 friendlyname  # 运行端口 4000 到 90 的“友好名称”映射
  docker run -d -p 4000:80 friendlyname         # 内容相同，但在分离模式下
  docker ps                                 # 查看所有正在运行的容器的列表
  docker stop &amp;lt;hash&amp;gt;                     # 平稳地停止指定的容器
  docker ps -a           # 查看所有容器的列表，甚至包含未运行的容器
  docker kill &amp;lt;hash&amp;gt;                   # 强制关闭指定的容器
  docker rm &amp;lt;hash&amp;gt;              # 从此机器中删除指定的容器
  docker rm $(docker ps -a -q)           # 从此机器中删除所有容器
  docker images -a                               # 显示此机器上的所有镜像
  docker rmi &amp;lt;imagename&amp;gt;            # 从此机器中删除指定的镜像
  docker rmi $(docker images -q)             # 从此机器中删除所有镜像
  docker login             # 使用您的 Docker 凭证登录此 CLI 会话
  docker tag &amp;lt;image&amp;gt; username/repository:tag  # 标记 &amp;lt;image&amp;gt; 以上传到镜像库
  docker push username/repository:tag            # 将已标记的镜像上传到镜像库
  docker run username/repository:tag                   # 运行镜像库中的镜像
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180428.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 28 Apr 2018 00:00:00 +0800</pubDate>
        <link>/docker</link>
        <guid isPermaLink="true">/docker</guid>
        
        
        <category>docker</category>
        
      </item>
    
      <item>
        <title>ife day4: 背景边框列表链接</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;background&lt;/li&gt;
  &lt;li&gt;background-color&lt;/li&gt;
  &lt;li&gt;background-image&lt;/li&gt;
  &lt;li&gt;background-repeat&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;background-position&lt;/p&gt;

    &lt;p&gt;body {
      font-family: sans-serif;
      background-color: #F0F8FF;
      border: 40px solid black;
      border-image-source: url(https://mdn.mozillademos.org/files/13060/border-image.png);
      border-image-slice: 40;
      border-image-repeat: round;
  }&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;边框&quot;&gt;边框&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;border&lt;/li&gt;
  &lt;li&gt;border-color&lt;/li&gt;
  &lt;li&gt;border-style&lt;/li&gt;
  &lt;li&gt;border-width&lt;/li&gt;
  &lt;li&gt;border-radius&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;列表&quot;&gt;列表&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;list-style&lt;/li&gt;
  &lt;li&gt;list-style-type&lt;/li&gt;
  &lt;li&gt;list-style-image&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;a:link&lt;/li&gt;
  &lt;li&gt;a:visited&lt;/li&gt;
  &lt;li&gt;a:hover&lt;/li&gt;
  &lt;li&gt;a:active&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 00:00:00 +0800</pubDate>
        <link>/ife_day4</link>
        <guid isPermaLink="true">/ife_day4</guid>
        
        
        <category>front-end</category>
        
        <category>html</category>
        
        <category>ife</category>
        
      </item>
    
      <item>
        <title>ife day4: 背景边框列表链接</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;background&lt;/li&gt;
  &lt;li&gt;background-color&lt;/li&gt;
  &lt;li&gt;background-image&lt;/li&gt;
  &lt;li&gt;background-repeat&lt;/li&gt;
  &lt;li&gt;background-position
    &lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;  body {
      font-family: sans-serif;
      background-color: #F0F8FF;
      border: 40px solid black;
      border-image-source: url(https://mdn.mozillademos.org/files/13060/border-image.png);
      border-image-slice: 40;
      border-image-repeat: round;
  }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;边框&quot;&gt;边框&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;border&lt;/li&gt;
  &lt;li&gt;border-color&lt;/li&gt;
  &lt;li&gt;border-style&lt;/li&gt;
  &lt;li&gt;border-width&lt;/li&gt;
  &lt;li&gt;border-radius&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;列表&quot;&gt;列表&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;list-style&lt;/li&gt;
  &lt;li&gt;list-style-type&lt;/li&gt;
  &lt;li&gt;list-style-image&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;a:link&lt;/li&gt;
  &lt;li&gt;a:visited&lt;/li&gt;
  &lt;li&gt;a:hover&lt;/li&gt;
  &lt;li&gt;a:active&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 00:00:00 +0800</pubDate>
        <link>/ife_day4.1</link>
        <guid isPermaLink="true">/ife_day4.1</guid>
        
        
        <category>front-end</category>
        
        <category>html</category>
        
        <category>ife</category>
        
      </item>
    
      <item>
        <title>ife day3: CSS基础</title>
        <description>&lt;h2 id=&quot;css规则&quot;&gt;CSS规则&lt;/h2&gt;

&lt;p&gt;由两部分组成： 选择器及一条或多条声明。
&lt;img src=&quot;/imgs/ct_css_selector.gif&quot; alt=&quot;CSS语法&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;选择器&quot;&gt;选择器&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;元素/类型选择器
    &lt;pre&gt;&lt;code&gt;  p {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;类选择器
    &lt;pre&gt;&lt;code&gt;  class=&quot;first done&quot;
  .first {}
  .done {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;id选择器
    &lt;pre&gt;&lt;code&gt;  id=&quot;rude&quot; id唯一
  #rude {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;通用选择器
    &lt;pre&gt;&lt;code&gt;  \* {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;属性选择器
    &lt;pre&gt;&lt;code&gt;  [attr] {} 有attr的元素
  [attr=val] {} attr值为val的元素
  [attr~=val] {} attr值包含val
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;伪类
    &lt;pre&gt;&lt;code&gt;  :active, :focus, :hover, ...
  a:visited {}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;组合器
    &lt;pre&gt;&lt;code&gt;  A,B {} 或
  A B {} B是A的后代结点
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;常用属性&quot;&gt;常用属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;color&lt;/li&gt;
  &lt;li&gt;font-family&lt;/li&gt;
  &lt;li&gt;font-style&lt;/li&gt;
  &lt;li&gt;font-weight&lt;/li&gt;
  &lt;li&gt;font-size&lt;/li&gt;
  &lt;li&gt;text-align&lt;/li&gt;
  &lt;li&gt;text-shadow&lt;/li&gt;
  &lt;li&gt;line-height&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 00:00:00 +0800</pubDate>
        <link>/ife_day3</link>
        <guid isPermaLink="true">/ife_day3</guid>
        
        
        <category>front-end</category>
        
        <category>html</category>
        
        <category>ife</category>
        
      </item>
    
      <item>
        <title>Elixir - Today I Learned</title>
        <description>&lt;h2 id=&quot;1-elixir-with-macro---and-&quot;&gt;1. Elixir with macro &lt;code&gt;&amp;lt;-&lt;/code&gt; and &lt;code&gt;=&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;So Elixir &lt;a href=&quot;https://hexdocs.pm/elixir/Kernel.SpecialForms.html#with/1&quot;&gt;with macro&lt;/a&gt; accepts &lt;strong&gt;Matching clauses&lt;/strong&gt; &lt;code&gt;&amp;lt;-&lt;/code&gt; and &lt;strong&gt;Bare expressions&lt;/strong&gt; &lt;code&gt;=&lt;/code&gt;. Both match patterns and do not leak variables assigned inside these structures.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;with {:ok, width} &amp;lt;- Map.fetch(%{width: 10}, :width),
  do: {:ok, 2 * width}
#=&amp;gt; {:ok, 20}

with {:ok, width} = Map.fetch(%{width: 10}, :width),
  do: {:ok, 2 * width}
#=&amp;gt; {:ok, 20}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what is the difference between these?&lt;/p&gt;

&lt;p&gt;When a match fails, matching clauses &lt;code&gt;&amp;lt;-&lt;/code&gt; returns &lt;strong&gt;failed result&lt;/strong&gt; but bare expressions &lt;code&gt;=&lt;/code&gt; raises a &lt;code&gt;MatchError&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;with {:ok, width} &amp;lt;- Map.fetch(%{height: 10}, :width),
  do: {:ok, 2 * width}
#=&amp;gt; :error

with {:ok, width} = Map.fetch(%{height: 10}, :width),
  do: {:ok, 2 * width}
#=&amp;gt; ** (MatchError) no match of right hand side value: :error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another difference is that &lt;code&gt;when&lt;/code&gt; guard is only available for matching clause.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;with {:ok, width} when is_number(width) &amp;lt;- Map.fetch(%{width: 10}, :width),
  do: {:ok, 2 * width}
#=&amp;gt; {:ok, 20}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;2-binary-pattern-matching&quot;&gt;2. Binary pattern matching&lt;/h2&gt;

&lt;p&gt;You might be familiar with the most popular form of Elixir pattern matching involving tuples:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex &amp;gt; {:ok, x} = {:ok, 1000}
{:ok, 1000}
iex &amp;gt; x
1000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also pattern match binaries:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex &amp;gt; &amp;lt;&amp;lt;1, y, 2&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 255, 2&amp;gt;&amp;gt;
&amp;lt;&amp;lt;1, 255, 2&amp;gt;&amp;gt;
iex &amp;gt; y
255
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gets powerful when you’re able to match binary formats.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex &amp;gt; &amp;lt;&amp;lt;x :: binary-1, y :: binary-2, z :: binary&amp;gt;&amp;gt; = &amp;lt;&amp;lt;1, 255, 254, 2&amp;gt;&amp;gt;
&amp;lt;&amp;lt;1, 255, 254, 2&amp;gt;&amp;gt;
iex &amp;gt; x
&amp;lt;&amp;lt;1&amp;gt;&amp;gt;
iex &amp;gt; y
&amp;lt;&amp;lt;255, 254&amp;gt;&amp;gt;
iex &amp;gt; z
&amp;lt;&amp;lt;2&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here’s an &lt;a href=&quot;http://www.zohaib.me/binary-pattern-matching-in-elixir/&quot;&gt;article&lt;/a&gt; about using binary pattern matching to parse a png file.&lt;/p&gt;

&lt;h2 id=&quot;3-word-lists-for-atoms&quot;&gt;3. Word Lists For Atoms&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;~w&lt;/code&gt; sigil allows you to create a list of words (i.e. strings).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;&amp;gt; ~w(one two three)
[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It sets itself apart though with some modifiers. The default behavior
matches the &lt;code&gt;s&lt;/code&gt; modifier (for strings).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;&amp;gt; ~w(one two three)s
[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Where it gets more interesting is with the &lt;code&gt;a&lt;/code&gt; modifier allowing you to
create a list of atoms.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;&amp;gt; ~w(one two three)a
[:one, :two, :three]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: there is a third modifier, &lt;code&gt;c&lt;/code&gt;, for char lists.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;&amp;gt; ~w(one two three)c
['one', 'two', 'three']
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://elixir-lang.org/getting-started/sigils.html&quot;&gt;source&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-find-and-open-port-with-elixir&quot;&gt;4. Find and Open Port with Elixir&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex(1)&amp;gt; {:ok, port} = :gen_tcp.listen(0, []) #listen on an available port
{:ok, #Port&amp;lt;0.1465&amp;gt;}
iex(2)&amp;gt; {:ok, port_number} = :inet.port(port) #get the port number of that port
{:ok, 63470}
iex(3)&amp;gt; port_number #here is the port number!
63470
iex(4)&amp;gt; Port.close port #go ahead and close that port if you want
true
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;5-virtual-fields-with-ecto-schema&quot;&gt;5. Virtual Fields With Ecto Schema&lt;/h2&gt;

&lt;p&gt;If you’d like to include a particular key-value pair in an Ecto changeset,
it needs to be included as a field in the schema. In the case of something
akin to a password field, you want to be able to perform validations against
it, but the password itself does not have a column in the database. In other
words, you want to use the password in memory as part of the validation
process but not save it to the database. To accomplish this, you need to
specify that it is a &lt;code&gt;virtual&lt;/code&gt; field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;schema &quot;users&quot; do
  field :username, :string
  field :password_digest, :string
  field :password, :string, virtual: true
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With that schema, you can then validate the &lt;code&gt;:password&lt;/code&gt; and transform it
into the corresponding &lt;code&gt;:password_digest&lt;/code&gt; field.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;def registration_changeset(model, params) do
  model
  |&amp;gt; changeset(params)                  # do other standard validations
  |&amp;gt; cast(params, [:password])          # include :password in the changeset
  |&amp;gt; validate_length(:password, min: 8) # validations
  |&amp;gt; put_pass_hash()                    # transform into :password_digest
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Mix xref and Elixir compiler warnings&lt;/p&gt;

&lt;p&gt;The &lt;a href=&quot;https://elixir-lang.org/blog/2016/06/21/elixir-v1-3-0-released/&quot;&gt;release&lt;/a&gt; of Elixir v1.3 added a mix task called &lt;code&gt;xref&lt;/code&gt; for performing cross reference checks of your code. &lt;code&gt;mix xref&lt;/code&gt; gives us some handy tools!&lt;/p&gt;

&lt;h2 id=&quot;6-find-unreachable-code&quot;&gt;6. Find unreachable code:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;❯ mix xref unreachable
lib/exonk8s/foo.ex:16: SomeModule.non_existant/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Find callers of modules and functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;❯ mix xref callers SomeModule
lib/exonk8s/foo.ex:16: SomeModule.non_existant/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Generate a dependency graph:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;&amp;gt; mix xref graph
lib/exonk8s.ex
├── lib/exonk8s/repo.ex
└── lib/router.ex
    └── lib/exonk8s/musician_controller.ex (compile)
        ├── lib/exonk8s/foo.ex
        ├── lib/exonk8s/musician.ex
        └── lib/exonk8s/repo.ex
...snipped for brevity
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;a href=&quot;https://elixir-lang.org/blog/2018/01/17/elixir-v1-6-0-released/&quot;&gt;release&lt;/a&gt; of Elixir v1.6 added the module attribute &lt;code&gt;@deprecated&lt;/code&gt; to enable library authors to warn users of deprecated functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;❯ mix xref deprecated
Compiling 2 files (.ex)
Foo Loaded
warning: ExOnK8s.Foo.lazy/0 is deprecated. You should be more eager.
  lib/exonk8s/musician_controller.ex:10

lib/exonk8s/musician_controller.ex:10: ExOnK8s.Foo.lazy/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Lastly I should note that &lt;code&gt;xref deprecated&lt;/code&gt; and &lt;code&gt;xref unreachable&lt;/code&gt; are included in the compiler warnings, so you you’ve likely seen these at work even if you didn’t know they were there.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://hexdocs.pm/mix/Mix.Tasks.Xref.html#content&quot;&gt;Learn more&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;7-view-your-outdated-packages&quot;&gt;7. View your outdated packages&lt;/h2&gt;

&lt;p&gt;To see which packages in a mix app need updating, you can run &lt;code&gt;mix hex.outdated&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ mix hex.outdated
Dependency           Current  Latest  Update possible
appsignal            1.3.2    1.3.3   Yes
basic_auth           2.1.4    2.1.4
cachex               2.1.0    2.1.0
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It prints out a handy table letting you quickly view the current and latest versions and if they can be updated. If &lt;code&gt;Update possible&lt;/code&gt; is &lt;code&gt;No&lt;/code&gt;, check your semantic version lockdown of that package in &lt;code&gt;mix.exs&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mix hex.outdated&lt;/code&gt; accepts a few arguments:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;--all&lt;/code&gt;  which shows all outdated packages, including children of packages defined in mix.exs&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;--pre&lt;/code&gt; which include pre-releases when checking for newer versions (be adventurous!)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Visualize Your Elixir Dependencies&lt;/p&gt;

&lt;h2 id=&quot;8-to-visualize-your-elixir-dependencies-try-this&quot;&gt;8. To visualize your Elixir dependencies, try this:&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ mix deps.tree
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This prints a tree showing your dependencies (and their dependencies):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ mix deps.tree
tilex
├── gettext ~&amp;gt; 0.13 (Hex package)
├── hackney 1.8.0 (Hex package)
│   ├── certifi 1.1.0 (Hex package)
│   ├── idna 4.0.0 (Hex package)
│   ├── metrics 1.0.1 (Hex package)
│   ├── mimerl 1.0.2 (Hex package)
│   └── ssl_verify_fun 1.1.1 (Hex package)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;9-phoenix-will-watch-your-js-for-you-just-watch&quot;&gt;9. Phoenix will watch your JS for you, just watch!&lt;/h2&gt;

&lt;p&gt;With es6 javascript ecosystems most compilation/transpilation is done with watchers, programs that watch for changes in your code and then trigger compilation based on the changes you’ve made.&lt;/p&gt;

&lt;p&gt;Phoenix has a method of integrating those watchers into the server itself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;config :myapp, MyApp.Endpoint,
  watchers: [yarn: [&quot;run&quot;, &quot;watch&quot;, cd: Path.expand(&quot;../assets&quot;, __DIR__)]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above configuration goes in &lt;code&gt;config/dev.exs&lt;/code&gt; and runs the watch command whenever you start the server/endpoint.  The keyword option &lt;code&gt;cd&lt;/code&gt; is as of yet undocumented, but does what you think it does, changes the directory to the path you configure, which by convention in Phoenix 1.3 would be the assets directory.  &lt;code&gt;cd&lt;/code&gt; is the only keyword option.&lt;/p&gt;

&lt;p&gt;The watchers start when you run your server.  Just make a change to your javascript and refresh the page!&lt;/p&gt;

&lt;h2 id=&quot;10-setting-breaks-in-iex-for-debugging&quot;&gt;10. Setting breaks in IEx for debugging&lt;/h2&gt;

&lt;p&gt;With the release of Elixir 1.5 comes some handy new IEx helpers, one of which is the ability to add break points throughout your code.&lt;/p&gt;

&lt;p&gt;You can add a break to any function using &lt;code&gt;break!/2&lt;/code&gt; or &lt;code&gt;break!/4&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;defmodule MyModule do
  def hello(name) do
    &quot;hello &quot; &amp;lt;&amp;gt; name
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;iex(1)&amp;gt; break!(MyModule.hello/ 1)
or
iex(1)&amp;gt; break!(MyModule, :hello, 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both &lt;code&gt;break/2&lt;/code&gt; and &lt;code&gt;break/4&lt;/code&gt; accept an additional argument for how many stops you want to make. Useful for recursive functions where you may want to stop multiple times.&lt;/p&gt;

&lt;p&gt;To see what breaks you have use  &lt;code&gt;breaks/0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;iex(1)&amp;gt; breaks()
 ID   Module.function/arity   Pending stops
---- ----------------------- ---------------
 1    MyModule.hello/1        1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now when you call the function, you’ll be placed into the a debugger and you can inspect whats being passed in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;iex(4)&amp;gt; MyModule.hello(&quot;world&quot;)
Break reached: MyModule.hello/1 (lib/my_module.ex:2)
    1: defmodule MyModule do
    2:   def hello(name) do
    3:     &quot;hello &quot; &amp;lt;&amp;gt; name
    4:   end
pry(1)&amp;gt; name
&quot;world&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To exit the break and start a new shell process use &lt;code&gt;respawn/0&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;pry(2)&amp;gt; respawn
Interactive Elixir (1.5.0) - press Ctrl+C to exit (type h() ENTER for help)
&quot;hello world&quot;
iex(1)&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20180427.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 27 Apr 2018 00:00:00 +0800</pubDate>
        <link>/elixir_today_i_learned</link>
        <guid isPermaLink="true">/elixir_today_i_learned</guid>
        
        
        <category>elixir</category>
        
        <category>phoenix</category>
        
      </item>
    
  </channel>
</rss>
