<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 28 Jan 2016 19:41:55 +0800</pubDate>
    <lastBuildDate>Thu, 28 Jan 2016 19:41:55 +0800</lastBuildDate>
    <generator>Jekyll v3.1.0</generator>
    
      <item>
        <title>shared ptr</title>
        <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;atomic&amp;gt;

using Lock = std::lock_guard&amp;lt;std::mutex&amp;gt;;

static std::atomic&amp;lt;int&amp;gt; s_test_count(3);
class Demo;
using DemoPtr = std::shared_ptr&amp;lt;Demo&amp;gt;;
class Demo : public std::enable_shared_from_this&amp;lt;Demo&amp;gt;
{
public:
    Demo()
    : _testValue(0)
    , _atomicValue(0)
    {
        
    }
    
    ~Demo()
    {
        std::cout &amp;lt;&amp;lt; &quot;~Demo()&quot; &amp;lt;&amp;lt; std::endl;
    }
    
    void test1()
    {
        std::thread t([this]{
            std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
            
            --s_test_count;
        });
        t.detach();
        {
            Lock l(_testValueMutex);
            ++_testValue;
        }
        std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
    }
    
    void test2()
    {
        {
            auto ptr = shared_from_this();
            std::thread t([this, ptr]{
                std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
                std::this_thread::sleep_for(std::chrono::seconds(1));
                {
                    Lock l(_testValueMutex);
                    ++_testValue;
                }
                std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
                
                --s_test_count;
            });
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }
    
    void test3()
    {
        {
            std::thread t(std::bind(&amp;amp;Demo::_theadFunc, this));
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }
    
    void test4()
    {
        {
            std::thread t(std::bind(&amp;amp;Demo::_theadFunc, shared_from_this()));
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }

    void test5()
    {
        auto ptr = shared_from_this();
        for (auto j=0; j&amp;lt;20; ++j) {
            std::thread t([this, ptr]{
                std::this_thread::sleep_for(std::chrono::seconds(1));
                ++_atomicValue;
                std::cerr &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
            });
            t.detach();
        }
        while (_atomicValue != 20) {
            std::this_thread::yield();
        }
        --s_test_count;
    }
private:
    std::mutex _testValueMutex;
    int _testValue;
    std::atomic&amp;lt;int&amp;gt; _atomicValue;
    
    void _theadFunc()
    {
        std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        {
            Lock l(_testValueMutex);
            ++_testValue;
        }
        std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        
        --s_test_count;
    }
};

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &amp;lt;&amp;lt; &quot;Hello, World!\n&quot;;
//	{
//		// test 1 crash
//		auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
//		std::cout &amp;lt;&amp;lt; &quot;Before test1: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//		demoPtr-&amp;gt;test1();
//		std::cout &amp;lt;&amp;lt; &quot;After test1: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//	}
    {
        //test 2
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test2: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test2();
        std::cout &amp;lt;&amp;lt; &quot;After test2: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
//	{
//		//test 3 crash
//		auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
//		std::cout &amp;lt;&amp;lt; &quot;Before test3: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//		demoPtr-&amp;gt;test3();
//		std::cout &amp;lt;&amp;lt; &quot;After test3: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//	}
    {
        //test 4
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test4: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test4();
        std::cout &amp;lt;&amp;lt; &quot;After test4: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
    {
        //test 5
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test5: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test5();
        std::cout &amp;lt;&amp;lt; &quot;After test5: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
    
    while (s_test_count &amp;gt; 0) {
        std::this_thread::yield();
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>/c++shared_ptr</link>
        <guid isPermaLink="true">/c++shared_ptr</guid>
        
        
        <category>c++</category>
        
        <category>shared_ptr</category>
        
        <category>atomic</category>
        
      </item>
    
      <item>
        <title>AutoBuild(3)</title>
        <description>&lt;p&gt;今天svn提交莫名奇妙卡住，提交成功了，但svn命令一直不返回。强关了后cleanup，再更新后就没有更新了。
可见提交其实已经成功。删了重新checkout问题依旧。&lt;/p&gt;

&lt;p&gt;为什么提交成功了命令行却一直不返回呢？忽然想到之前为了做AutoBuild系统，hook了svn提交。提交后用wget
执行了通知编译服务器操作，而编译服务器不在线通知不到，就一直卡在那。&lt;/p&gt;

&lt;p&gt;知道问题原因了，修改wget超时及重试次数，并改为后台运行，搞定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/wget http://xxx --tries=1 --spider --timeout=5 --background
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>/autobuild(3)</link>
        <guid isPermaLink="true">/autobuild(3)</guid>
        
        
        <category>autobuild</category>
        
        <category>svn</category>
        
      </item>
    
      <item>
        <title>分布式服务器设计</title>
        <description>&lt;h2 id=&quot;jone-zhangs-blog----httpwwwcnblogscomccdevp3341234html&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/ccdev/p/3341234.html&quot;&gt;Jone Zhang’s Blog – 高并发服务端分布式系统设计概要&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160121_jone_zhang.jpg&quot; alt=&quot;分布式系统设计图&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由N台机器组合而成，其中Global Master一台，Global Slave一台到多台，两者之间保持强一致性并完全同步，&lt;br /&gt;
可由Global Slave随时顶替Global Master工作，它们被Global Heartbeat（一台）来管理，保证有一个Global Master正常工作；&lt;br /&gt;
Global Heartbeat由于无压力，通常认为其不能挂掉，如果它挂掉了，则必须人工干预才能恢复正常；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由多个groups合成，每一个group负责相应业务的数据的存取，它们是数据节点，是真正抗压力的地方，&lt;br /&gt;
每一个group由一个Group Master和一个到多个Group Slave构成，Group Master作为该group的主节点，提供读和写，&lt;br /&gt;
而Group Slave则只提供读服务且保证这些Group Slave节点中，至少有一个和Group Master保持完全同步，&lt;br /&gt;
剩余的Group Slave和Group Master能够达到最终一致，它们之间以“半同步”模式工作保证最终一致性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的健康状态由Global Master来管理，Global Master向group发送管理信息，并保证有一个Group Master正常工作，&lt;br /&gt;
若Group Master宕机，在该group内通过分布式选举产生新的Group Master顶替原来宕机的机器继续工作，&lt;br /&gt;
但仍然有一小段时间需要中断写服务来切换新的Group Master；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的底层是实际的存储系统，File system，它们是无状态的，即，由分布式选举产生的Group Master可以在原来的File system上继续工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client的上端可认为是Web请求，Client在“首次”进行数据读写时，向Global Master查询相应的group信息，并将其缓存，&lt;br /&gt;
后续将直接与相应的group进行通信；为避免大量“首次”查询冲垮Global Master，在Client与Global Master之间增加DNS负载均衡，&lt;br /&gt;
可由Global Slave分担部分查询工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当Client已经拥有足够的group信息时，它将直接与group通信进行工作，从而真正的压力和流量由各个group分担，并处理完成需要的工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;我的分布式游戏服务器设计&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160121_my_server.jpg&quot; alt=&quot;分布式游戏服务器设计图&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>/server</link>
        <guid isPermaLink="true">/server</guid>
        
        
        <category>server</category>
        
        <category>分布式</category>
        
      </item>
    
      <item>
        <title>redmine</title>
        <description>&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;ruby&quot;&gt;安装ruby&lt;/h2&gt;

    &lt;p&gt;gpg2 –keyserver hkp://keys.gnupg.net –recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
 curl -L https://get.rvm.io | bash -s stable
 source /etc/profile.d/rvm.sh
 rvm list known
 rvm install ruby-head&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;rails&quot;&gt;安装rails&lt;/h2&gt;

    &lt;p&gt;gem install rails&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <link>/redmine</link>
        <guid isPermaLink="true">/redmine</guid>
        
        
        <category>redmine</category>
        
      </item>
    
      <item>
        <title>jekyll templates</title>
        <description>&lt;h2 id=&quot;variables&quot;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Variables are surrounded by &lt;code&gt;\{\{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;My first name is \{\{ first_name  }}. My last name is \{\{ last_name  }}.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;tags&quot;&gt;Tags&lt;/h2&gt;

&lt;p&gt;Tags provide arbitrary logic in the rendering process.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\{\% if user.is_authenticated %}Hello, \{\{ user.username  }}.\{\% endif %}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;filters&quot;&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filters transform the values of variables and tag arguments.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\{\{ site.time | date_to_xmlschema  }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;comments&quot;&gt;Comments&lt;/h2&gt;

&lt;p&gt;Comments look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;\{\# this won&#39;t be rendered #}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160117.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
        <link>/jekyll-templates</link>
        <guid isPermaLink="true">/jekyll-templates</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>Auto-Refresh code in HTML</title>
        <description>&lt;h2 id=&quot;use-meta-tag&quot;&gt;use meta tag&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&amp;gt;
Please within the `head` tag of your html document, this `meta` tag  
will instruct the browser to refresh every `5` seconds.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;AutoBuild系统中我想有个页面能够一直看到当前项目的状态，先用着这个方法去定时查询。
以后看有没有办法实现通知。^_^&lt;/p&gt;

&lt;h2 id=&quot;click-to-refresh&quot;&gt;click to refresh&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;body onclick=&quot;window.location.reload();&quot;&amp;gt;
    ...
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;scroll-to-bottom&quot;&gt;scroll to bottom&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;window.scrollTo(0, document.body.scrollHeight);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160116.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Jan 2016 00:00:00 +0800</pubDate>
        <link>/html-auto-refresh</link>
        <guid isPermaLink="true">/html-auto-refresh</guid>
        
        
        <category>html</category>
        
      </item>
    
      <item>
        <title>erlang/opt doc</title>
        <description>&lt;p&gt;&lt;a href=&quot;/otp_doc/doc/index.html&quot;&gt;erlang/opt doc&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <link>/otp-doc</link>
        <guid isPermaLink="true">/otp-doc</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>erlang执行shell</title>
        <description>&lt;h2 id=&quot;oscmdcmd&quot;&gt;os:cmd(Cmd)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;cmd(Command) -&amp;gt; string()
Types:
Command = atom() | io_lib:chars()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;erlangopenportportname-portsettings&quot;&gt;erlang:open_port(PortName, PortSettings)&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;open_port(PortName, PortSettings) -&amp;gt; port()
Types:
PortName = 
    {spawn, Command :: string() | binary()} |
    {spawn_driver, Command :: string() | binary()} |
    {spawn_executable, FileName :: file:name()} |
    {fd, In :: integer() &amp;gt;= 0, Out :: integer() &amp;gt;= 0}
PortSettings = [Opt]
Opt = 
    {packet, N :: 1 | 2 | 4} |
    stream |
    {line, L :: integer() &amp;gt;= 0} |
    {cd, Dir :: string() | binary()} |
    {env, Env :: [{Name :: string(), Val :: string() | false}]} |
    {args, [string() | binary()]} |
    {arg0, string() | binary()} |
    exit_status |
    use_stdio |
    nouse_stdio |
    stderr_to_stdout |
    in |
    out |
    binary |
    eof |
    {parallelism, Boolean :: boolean()} |
    hide
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;loop2() -&amp;gt;
    receive
        {build} -&amp;gt;
            io:format(&quot;build ...~n&quot;),
            Port = open_port({spawn_executable, &quot;path/build_ios_nolog.sh&quot;}, [stream, exit_status, eof, hide]),
            Result = get_data(Port, []),
            io:format(&quot;~p~n&quot;, [Result]),
            loop2();
        stop -&amp;gt;
            ok;
        _ -&amp;gt;
            io:format(&quot;recv unknown message!~n&quot;),
            loop2()
    end.

get_data(Port, Sofar) -&amp;gt;
    receive
        {Port, {data, Bytes}} -&amp;gt;
            get_data(Port, [Sofar|Bytes]);
        {Port, eof} -&amp;gt;
            Port ! {self(), close},
            receive
                {Port, closed} -&amp;gt; true
            end,
            receive
                {&#39;EXIT&#39;,  Port,  _} -&amp;gt; ok
            after 1 -&amp;gt; ok
            end,
            ExitCode =
            receive
                {Port, {exit_status, Code}} -&amp;gt; Code
            end,
            {ExitCode, lists:flatten(Sofar)}
            %{ExitCode, Sofar}
    end.
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <link>/erlang-shell</link>
        <guid isPermaLink="true">/erlang-shell</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>记录一次内存错误debug</title>
        <description>&lt;p&gt;项目在某页面崩溃，ide断在EventDispatcher::cleanToRemovedListeners()。
据断点处信息_toRemovedListeners里有的值retaincount已经为0了，一定是多释放了。
但找半天没找到哪些地方用的不对，都是在onEnter里添加监听，在onExit里取消监听。
去到2dx里代码仓库看最新的提交也没发现有修复类似bug的，应该还是自己代码的原因。
最后没办法了，在所有代码使用listener的地方，添加时先retain，remove时再release。
改着改着就发现一个自定义控件的一个方法在remove里没把listener指针置空，导致onExit时
又释放了一遍。再回头看崩溃页面，果然用到过这个控件。我*&lt;/p&gt;

&lt;p&gt;这种内存错误bug最难调了，崩溃时有效信息不多，而且不一定在什么时候、什么地方才会表现出来。
写代码时一定要注意，指针释放后置空。&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <link>/2dx-debug</link>
        <guid isPermaLink="true">/2dx-debug</guid>
        
        
        <category>cocos2d-x</category>
        
        <category>debug</category>
        
      </item>
    
      <item>
        <title>My first post</title>
        <description>&lt;p&gt;Stay hungry, Stay foolish.&lt;br /&gt;
求知若饥，虚心若愚。&lt;br /&gt;
2016.1.10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160110.jpg&quot; alt=&quot;小宝&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Jan 2016 21:04:46 +0800</pubDate>
        <link>/fist-post</link>
        <guid isPermaLink="true">/fist-post</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
  </channel>
</rss>
