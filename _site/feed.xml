<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>https://xiaobin0860.github.io/</link>
    <atom:link href="https://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 07 Feb 2023 01:04:29 +0800</pubDate>
    <lastBuildDate>Tue, 07 Feb 2023 01:04:29 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>c++ Concepts</title>
        <description>&lt;h2 id=&quot;泛型编程&quot;&gt;泛型编程&lt;/h2&gt;

&lt;p&gt;长期以来，软件重用一直都是软件工程追求的目标，而泛型编程为软件重用创造了可能性。所谓泛型编程，指的是通过组件的灵活组合来实现软件，而这些组件通过对定义做出最小“假设”来实现最大灵活性。&lt;/p&gt;

&lt;h2 id=&quot;c模板&quot;&gt;c++模板&lt;/h2&gt;

&lt;p&gt;在函数与类的定义 / 声明前，加上模板列表，在列表中指定在函数以及类的定义 / 声明中使用的模板参数&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//class/typename定义的T/U是类型参数，size_t定义的S是非类型参数
template&amp;lt;size_t S, class T, typename u&amp;gt;
void fill_container(T&amp;amp; container, U v) {
    for (size_t i=0;i&amp;lt;S;++i) {
        container.push_back(v);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;显示实例化，加快编译速度，其它编译单元直接用显示实例化的符号
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; template&amp;lt;typename T, typename U&amp;gt;
 void fill_container(T&amp;amp; container, U v, size_t s) {
     for (size_t i=0;i&amp;lt;s;++i) {
         container.push_back(v);
     }
 }
 template
 void fill_container&amp;lt;std::vector&amp;lt;int&amp;gt;, int&amp;gt;(std::vector&amp;lt;int&amp;gt;&amp;amp;, int, size_t);
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;特化 为特定参数类型提供特定实现版本，提供类似函数重载的支持
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; template&amp;lt;size_t Size, class T, typename U&amp;gt;
 void fill(T&amp;amp; collection, U value) {
     std::cout &amp;lt;&amp;lt; &quot;Universal&quot; &amp;lt;&amp;lt; std::endl;
     for (size_t i = 0; i != Size; ++i) {
         collection.push_back(value);
     }
 }
 template &amp;lt;&amp;gt;
 void fill&amp;lt;10, std::vector, double&amp;gt;(std::vector&amp;amp; collection, double value) {
     std::cout &amp;lt;&amp;lt; &quot;Explicit (full) template specialization&quot; &amp;lt;&amp;lt; std::endl;
     for (size_t i = 0; i != 10; ++i) {
         collection.push_back(value + 2.0);
     }
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;偏特化&lt;/li&gt;
  &lt;li&gt;不定参模板
    &lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt; double sum() {
     return 0.0;
 }
 template &amp;lt;typename T, typename... Targs&amp;gt;
 double sum(T value, Targs... Fargs) {
     return static_cast&amp;lt;double&amp;gt;(value) + sum(Fargs...);
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;类型约束晦涩难懂&lt;/li&gt;
  &lt;li&gt;生成的代码急速膨胀&lt;/li&gt;
  &lt;li&gt;ABI 兼容性糟糕 接口不要使用STL&lt;/li&gt;
  &lt;li&gt;错误消息很难理解&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;concepts&quot;&gt;Concepts&lt;/h2&gt;

&lt;p&gt;解决问题1和4，将一组通用的约束定义为一个&lt;code&gt;concept&lt;/code&gt;，并且，在定义模板函数与模板类中，直接使用这些&lt;code&gt;concept&lt;/code&gt;替换通用的&lt;code&gt;typename&lt;/code&gt;和&lt;code&gt;class&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template &amp;lt;参数模板&amp;gt;
concept 名称 = 约束表达式;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;class BaseClass {
public:
    int32_t getValue() const {
        return 1;
    }
};
template&amp;lt;class T&amp;gt;
concept DerivedOfBaseClass = std::is_base_of_v&amp;lt;BaseClass, T&amp;gt;;

template &amp;lt;DerivedOfBaseClass T&amp;gt;
void doGetValue(const T&amp;amp; a) {
    std::cout &amp;lt;&amp;lt; &quot;Get value:&quot; &amp;lt;&amp;lt; a.getValue() &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;通过约束与 concept 这两个 C++ 核心语言特性变更（高级抽象），实现了对模板参数列表与参数的约束的逻辑分离&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;从 C++20 标准及其演进标准之后，concept 之于 C++ 泛型编程，正如 class 之于 C++ 面向对象&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;约束表达式&quot;&gt;约束表达式&lt;/h2&gt;

&lt;p&gt;通过逻辑操作符的方式进行组合的，用于定义更复杂的 concept&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;template&amp;lt;class T&amp;gt;
concept Integral = std::is_integral_v&amp;lt;T&amp;gt;;
 
template&amp;lt;class T&amp;gt;
concept SignedIntegral = Integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; std::is_signed_v&amp;lt;T&amp;gt;;
 
template&amp;lt;class T&amp;gt;
concept UnsignedIntegral = Integral&amp;lt;T&amp;gt; &amp;amp;&amp;amp; !SignedIntegral&amp;lt;T&amp;gt;;
 
template &amp;lt;class T&amp;gt;
concept FloatingPoint = std::is_floating_point_v&amp;lt;T&amp;gt;;
 
template &amp;lt;class T&amp;gt;
concept Number = Integral&amp;lt;T&amp;gt; || FloatingPoint&amp;lt;T&amp;gt;;

template&amp;lt;typename T&amp;gt;
constexpr bool get_value() { return T::value; }
template&amp;lt;typename T&amp;gt;
    requires (sizeof(T) &amp;gt; 1 &amp;amp;&amp;amp; get_value&amp;lt;T&amp;gt;())
void f(T) {
    std::cout &amp;lt;&amp;lt; &quot;template version&quot; &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Feb 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/c++20_Concepts</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/c++20_Concepts</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>c++ Modules</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;p&gt;现在模块化编程，替代头文件，解决模块间符号可见性控制问题&lt;/p&gt;

&lt;h2 id=&quot;模块声明&quot;&gt;模块声明&lt;/h2&gt;

&lt;p&gt;编译单元默认&lt;code&gt;普通单元&lt;/code&gt;，&lt;code&gt;module&lt;/code&gt;关键字&lt;code&gt;模块单元&lt;/code&gt;，&lt;code&gt;export module&lt;/code&gt;定义模块对外接口&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;export module helloworld;
//符号默认对模块外不可见
void private_hello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; std::endl;
}
//定义外部可见函数
export void hello() {
    private_hello():
}
//导出整个namespace，不推荐
export namespace hname {
    int get_num() {
        return 0;
    }
}
//推荐namespace内细粒度控制
namespace xname {
    export int get_num() {
        return 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;导入模块&quot;&gt;导入模块&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;关键字导入模块，让被引用模块的符号在本编译单元可见，类似&lt;code&gt;using namespace&lt;/code&gt;，可以用&lt;code&gt;export import&lt;/code&gt;将导入符号对外导出&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;///bye.cpp
export module bye;
import &amp;lt;iostream&amp;gt;
export void goodbye() {
    std::cout &amp;lt;&amp;lt; &quot;Goodbye&quot; &amp;lt;&amp;lt; std::endl;
}

///helloworld.cpp
export module helloworld;
export import bye;
export void hello() {
    std::cout &amp;lt;&amp;lt; &quot;Hello World!&quot; &amp;lt;&amp;lt; std::endl;
}

///main.cpp
import helloworld;
int main() {
    helloe();
    goodbye();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;导入头文件&quot;&gt;导入头文件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;与&lt;code&gt;include&lt;/code&gt;区别是，通过&lt;code&gt;impor&lt;/code&gt;导入头文件的编译单元定义的&lt;code&gt;预处理宏&lt;/code&gt;，是无法被&lt;code&gt;import&lt;/code&gt;导入的文件访问的，可以用&lt;code&gt;模块片段&lt;/code&gt;来实现使用&lt;code&gt;预处理宏&lt;/code&gt;影响头文件&lt;/p&gt;

&lt;p&gt;全局模块片段&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;module;
//预处理宏指令
//模块声明
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;模块分区&quot;&gt;模块分区&lt;/h2&gt;

&lt;p&gt;模块的一个关键特性是可以划分为更多的子模块。在 C++ Modules 中，子模块主要有两种实现方式：通过模块名称进行区分(&lt;code&gt;utils.image&lt;/code&gt;)、利用模块分区特性(&lt;code&gt;模块名:分区名&lt;/code&gt;)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;//helloworld_a.cpp
export module helloworld:A;

//helloworld_b.cpp
export module helloworld:B

//helloworld.cpp
export module helloworld;
export import :A;
import :B;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;模块所有权&quot;&gt;模块所有权&lt;/h2&gt;

&lt;p&gt;使用模块的时候需要注意符号声明的所有权问题，这影响符号的实现位置和符号的&lt;code&gt;链接性(linkage)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-c++&quot;&gt;export module lib;
namespace hello { //命名空间不属于lib
    extern &quot;C++&quot; int32_t f(); //外部链接c++方式符号，不属于lib
    extern &quot;C&quot; int32_t g(); //外部链接c方式符号，不属于lib
    int32_t x(); //hello::x属于lib，只能被同模块编译单元使用
    export int32_t z(); //hello::z属于lib，可被其它模块编译单元使用
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 29 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/c++20_Modules</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/c++20_Modules</guid>
        
        
        <category>c++</category>
        
      </item>
    
      <item>
        <title>栈</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种“操作受限”的线性表，只允许从一端插入删除数据&lt;/li&gt;
  &lt;li&gt;后进先出，先进后出&lt;/li&gt;
  &lt;li&gt;顺序栈(数组)，链式栈(链表)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;入栈 O(1)&lt;/li&gt;
  &lt;li&gt;出栈 O(1)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;动态扩容&quot;&gt;动态扩容&lt;/h2&gt;

&lt;p&gt;底层动态扩容数组，栈满后申请更大空间，进行数据搬移&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;函数调用栈&lt;/li&gt;
  &lt;li&gt;表达式求值&lt;/li&gt;
  &lt;li&gt;括号匹配&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 29 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E6%A0%88</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E6%A0%88</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>链表</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种线性表数据结构&lt;/li&gt;
  &lt;li&gt;用&lt;code&gt;指针&lt;/code&gt;将一组零散的内存块(&lt;code&gt;结点&lt;/code&gt;)串联起来使用&lt;/li&gt;
  &lt;li&gt;插入、删除数据非常快速&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;单链表
    &lt;ul&gt;
      &lt;li&gt;查找 O(n)&lt;/li&gt;
      &lt;li&gt;插入和删除 O(1)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;循环链表 尾结点&lt;code&gt;next&lt;/code&gt;指向头结点&lt;/li&gt;
  &lt;li&gt;双向链表 &lt;code&gt;next&lt;/code&gt;后继指针，&lt;code&gt;prev&lt;/code&gt;前驱指针&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;链表适合插入、删除操作频繁的场景&lt;/li&gt;
  &lt;li&gt;双向链表比单链表插入、删除等操作简单、高效，适用更多情况&lt;/li&gt;
  &lt;li&gt;循环链表适合处理具有环型特点的数据，比如约瑟夫问题&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;练习&quot;&gt;练习&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;单链表反转&lt;/li&gt;
  &lt;li&gt;链表中环的检测&lt;/li&gt;
  &lt;li&gt;两个有序链表合并&lt;/li&gt;
  &lt;li&gt;删除链表倒数第 n 个结点&lt;/li&gt;
  &lt;li&gt;求链表的中间结点&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;编码技巧&quot;&gt;编码技巧&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;理解指针和引用的含义(地址)&lt;/li&gt;
  &lt;li&gt;警惕指针丢失和内存泄露&lt;/li&gt;
  &lt;li&gt;利用哨兵简化实现难度&lt;/li&gt;
  &lt;li&gt;重点留意边界条件处理&lt;/li&gt;
  &lt;li&gt;举例画图，辅助思考&lt;/li&gt;
  &lt;li&gt;多写多练，没有捷径&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 29 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E9%93%BE%E8%A1%A8</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E9%93%BE%E8%A1%A8</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>算法复杂度分析</title>
        <description>&lt;p&gt;数据结构和算法解决的是快和省的问题，即如何让代码运行得更快，更省存储空间。
可以用时间、空间复仇度分析来衡量算法好坏。&lt;/p&gt;

&lt;h2 id=&quot;大-o-复杂度表示法&quot;&gt;大 O 复杂度表示法&lt;/h2&gt;

&lt;p&gt;所有代码的执行时间&lt;code&gt;T(n)&lt;/code&gt;与每行代码的执行次数&lt;code&gt;f(n)&lt;/code&gt;成正比&lt;/p&gt;

&lt;p&gt;$T(n) = O(f(n))$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;大O时间复杂度&lt;/code&gt;表示代码执行时间随数据规模增长的变化趋势，也叫&lt;code&gt;渐进时间复杂度&lt;/code&gt;，简称&lt;code&gt;时间复杂度&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;时间复杂度分析&quot;&gt;时间复杂度分析&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;只关注循环执行次数最多的一段代码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加法法则：总复杂度等于量级最大的那段代码的复杂度&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;常见复杂度案例&quot;&gt;常见复杂度案例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;多项式量级&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;常量阶$O(1)$&lt;/li&gt;
      &lt;li&gt;对数阶$O(log_n)$&lt;/li&gt;
      &lt;li&gt;线性阶$O(n)$&lt;/li&gt;
      &lt;li&gt;线性对数阶$O(nlog_n)$&lt;/li&gt;
      &lt;li&gt;平方阶$O(n^2)$、立方阶$O(n^3)$…k 次方阶$O(n^k)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非多项式量级&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;指数阶$O(2^n)$&lt;/li&gt;
      &lt;li&gt;阶乘阶$O(n!)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;最好最坏情况时间复杂度&quot;&gt;(最好/最坏)情况时间复杂度&lt;/h2&gt;

&lt;p&gt;在(最理想/最糟糕)的情况下，执行这段代码的时间复杂度。&lt;/p&gt;

&lt;h2 id=&quot;平均情况时间复杂度&quot;&gt;平均情况时间复杂度&lt;/h2&gt;

&lt;p&gt;将各种情况发生的概率考虑进去，做加权平均。&lt;/p&gt;

&lt;h2 id=&quot;均摊时间复杂度&quot;&gt;均摊时间复杂度&lt;/h2&gt;

&lt;p&gt;特殊的平均时间复杂度&lt;/p&gt;

&lt;p&gt;每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。&lt;/p&gt;

&lt;h2 id=&quot;空间复杂度分析&quot;&gt;空间复杂度分析&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;空间复杂度&lt;/code&gt;全称是&lt;code&gt;渐进空间复杂度&lt;/code&gt;，表示算法的存储空间与数据规模之间的增长关系。&lt;/p&gt;
</description>
        <pubDate>Wed, 11 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>数组</title>
        <description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;一种线性表数据结构&lt;/li&gt;
  &lt;li&gt;用一组连续内存，存储相同类型的数据&lt;/li&gt;
  &lt;li&gt;支持随机访问，但插入删除低效&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作&quot;&gt;操作&lt;/h2&gt;

&lt;h3 id=&quot;随机访问&quot;&gt;随机访问&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;一维寻址公式：a[k]_address = base_address + k * type_size&lt;/li&gt;
  &lt;li&gt;二维寻址公式：对m * n数组，a[i][j] = base_address + (i * n + j) * type_size&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;插入操作&quot;&gt;插入操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最坏(在开头插入)O(n)，平均O(n)&lt;/li&gt;
  &lt;li&gt;最好(在末尾插入)O(1)&lt;/li&gt;
  &lt;li&gt;无序在第k位插入，可第k位插最后，写入第k位，O(1)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;删除操作&quot;&gt;删除操作&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最坏(在开头删除)O(n)，平均O(n)&lt;/li&gt;
  &lt;li&gt;最好(在末尾删除)O(1)&lt;/li&gt;
  &lt;li&gt;标记删除，以后触发真正删除操作，均摊&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;平时开发直接用编程语言提供的容器&lt;/li&gt;
  &lt;li&gt;特别底层开发，直接使用数组&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 11 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/%E6%95%B0%E7%BB%84</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/%E6%95%B0%E7%BB%84</guid>
        
        
        <category>算法</category>
        
      </item>
    
      <item>
        <title>类型系统</title>
        <description>&lt;h2 id=&quot;primitive-type&quot;&gt;primitive type&lt;/h2&gt;

&lt;p&gt;基本类型：interger, string, bool, array …&lt;/p&gt;

&lt;h2 id=&quot;product-type&quot;&gt;product type&lt;/h2&gt;

&lt;p&gt;struct 不同类型的乘积，取值是所有组合类型的笛卡尔积&lt;/p&gt;

&lt;h2 id=&quot;sum-type&quot;&gt;sum type&lt;/h2&gt;

&lt;p&gt;enum 不同类型的不相交集&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Option&amp;lt;T&amp;gt; {
   Some(T),
   None
}
enum Result&amp;lt;T, E&amp;gt; {
   Ok(T),
   Err(E)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;generic-type&quot;&gt;generic type&lt;/h2&gt;

&lt;p&gt;泛型，提升抽象程度，可看成是作用于类型的的特殊函数，
展开为新类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Option&amp;lt;u8&amp;gt;&lt;/code&gt;展开是&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-rust&quot;&gt;enum Option {
   Some(u8),
   None
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 06 Jan 2023 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/types</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/types</guid>
        
        
        <category>rust</category>
        
      </item>
    
      <item>
        <title>lua入门</title>
        <description>&lt;h2 id=&quot;首先介绍一下-lua-语言&quot;&gt;首先介绍一下 lua 语言：&lt;/h2&gt;

&lt;p&gt;它是一门动态类型语言。所谓动态就是运行时，静态就是编译时。&lt;br /&gt;
静态语言会在编译时做类型检查，通过报错帮助程序员发现问题。&lt;br /&gt;
动态语言没有编译环节，类型检查发生在运行时，查到错误就会抛出异常，&lt;br /&gt;
程序员需要自己保证类型正确，或者做好异常处理。&lt;br /&gt;
因为没有类型的约束，lua 语言非常灵活，可以编写一些复杂的逻辑。&lt;br /&gt;
除了动态语言共同的优势以外，lua 自身有两大优势：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;尾调用，使得程序员可以放心的写递归算法，不必担心 StackOverflow&lt;/li&gt;
  &lt;li&gt;标准化的 c api，使得 lua 语言可以与 c 语言互相调用，并且所写的 c 代码是跨平台的，不会因 lua 解释器不同而不同&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;一类型系统分为值类型和引用对象类型&quot;&gt;一、类型系统分为“值类型”和“引用（对象）类型”&lt;/h2&gt;

&lt;p&gt;值类型有 5 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;nil&lt;/code&gt;类型，值也是&lt;code&gt;nil&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;boolean&lt;/code&gt;类型，值为&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;number&lt;/code&gt;类型，默认由&lt;code&gt;double&lt;/code&gt;类型实现。&lt;code&gt;m^n&lt;/code&gt;，求&lt;code&gt;m&lt;/code&gt;的&lt;code&gt;n&lt;/code&gt;次方&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;string&lt;/code&gt;类型，&lt;code&gt;&apos;\0&apos;&lt;/code&gt;字符不会截断字符串，可以用&lt;code&gt;&apos;&lt;/code&gt;、&lt;code&gt;&quot;&lt;/code&gt;、&lt;code&gt;[[]]&lt;/code&gt;来构造字符串。&lt;br /&gt;
&lt;code&gt;#str&lt;/code&gt;，求 str 的字节数。&lt;code&gt;str=str..str&lt;/code&gt;，连接两个字符串&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;lightuserdata&lt;/code&gt;类型，对应 C 语言的指针值，是值不是对象&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;引用类型有 4 种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;function&lt;/code&gt;类型，用&lt;code&gt;function(参数列) end&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;类型，用&lt;code&gt;{}&lt;/code&gt;来构造这种对象&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;thread&lt;/code&gt;类型，不是线程，是协程，不具有并发功能，只能用来分隔不相干的逻辑。&lt;br /&gt;
每个&lt;code&gt;thread&lt;/code&gt;有自己的&lt;code&gt;call stack&lt;/code&gt;。由程序员调度所要执行的&lt;code&gt;thread&lt;/code&gt;，其它&lt;code&gt;thread&lt;/code&gt;会暂停&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;userdata&lt;/code&gt;类型，Cocos2dx 里的 c++类的实例，在 lua 里就是这种类型。&lt;br /&gt;
对比&lt;code&gt;lightuserdata&lt;/code&gt;，一个是指针本身（32 位或 64 位无符号整数），一个是指针指向的对象&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二function-相关知识&quot;&gt;二、function 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;传参和传返回值的时候，根据上一讲分的两大类，来传值或传引用。&lt;/li&gt;
  &lt;li&gt;除了传参和传返回值，&lt;code&gt;function&lt;/code&gt;还会自动捕获外部的变量，术语叫&lt;code&gt;upvalue&lt;/code&gt;，意思是上文中的变量。&lt;br /&gt;
&lt;code&gt;upvalue&lt;/code&gt; 一律传引用，也就是说，在函数内修改&lt;code&gt;upvalue&lt;/code&gt;，那么函数外也能看到这一改变。&lt;br /&gt;
利用自动捕获，&lt;code&gt;function&lt;/code&gt;可以当做容器用，要访问容器中的变量，就必须调用该函数，以达到封装的目的&lt;br /&gt;
lua 中很少做封装，常做的只有继承、多态。&lt;/li&gt;
  &lt;li&gt;尾调用。函数内出现&lt;code&gt;return func(...)&lt;/code&gt;，那么调用栈会先 pop 当前函数，然后把 func 压入调用栈。&lt;br /&gt;
这一机制的好处是，可以无限制使用递归算法，而不会发生 stack overflow。&lt;br /&gt;
坏处是，调用栈不完整，在栈上看到一个函数，难以推断是哪个函数调用了这一函数，&lt;br /&gt;
因为上一个函数可能已经出栈了。写或不写 return，可以控制是否使用尾调用&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三table-相关知识&quot;&gt;三、table 相关知识&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code&gt;table&lt;/code&gt;是哈希表，无序容器。当键是从 1 开始的连续整数时，可以当做数组来用（有序）&lt;/li&gt;
  &lt;li&gt;与函数自动捕获引用不同，table 可以存值进去&lt;/li&gt;
  &lt;li&gt;增、改：&lt;code&gt;t[k]=v&lt;/code&gt;&lt;br /&gt;
删：&lt;code&gt;t[k]=nil&lt;/code&gt;&lt;br /&gt;
查：&lt;code&gt;if t[k]~= nil then ...&lt;/code&gt;&lt;br /&gt;
无序遍历：&lt;code&gt;for k,v in pairs(t) do ...&lt;/code&gt;&lt;br /&gt;
有序遍历：&lt;code&gt;for i,v in ipairs(t) do ...&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;setmetatable(t,mt)&lt;/code&gt;用来给表 t 设置一个元表 mt，元表中存放的主要是元方法，&lt;br /&gt;
比如&lt;code&gt;__add&lt;/code&gt;, &lt;code&gt;__sub&lt;/code&gt;, &lt;code&gt;__mul&lt;/code&gt;, &lt;code&gt;__div&lt;/code&gt;, &lt;code&gt;__len&lt;/code&gt;, &lt;code&gt;__concat&lt;/code&gt;, &lt;code&gt;__gc&lt;/code&gt;。&lt;br /&gt;
前面几个相当于“运算符重载”，使 t 可以支持算术运算。gc 是垃圾回收的意思，相当于 t 的析构函数。&lt;br /&gt;
可以看出，mt 控制着 t 的行为&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四类与类的实例&quot;&gt;四、类与类的实例&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;二者都是&lt;code&gt;table&lt;/code&gt;，前者装有成员函数（共性），后者装有成员变量（个性）&lt;/li&gt;
  &lt;li&gt;语法糖 &lt;code&gt;instance:method(argument)&lt;/code&gt;&lt;br /&gt;
原型为 &lt;code&gt;instance[&apos;method&apos;](instance,argument)&lt;/code&gt;&lt;br /&gt;
先在实例表里查找成员函数，通常表里只有成员变量没有成员函数，这种情况下会触发&lt;code&gt;__index&lt;/code&gt;元方法，&lt;br /&gt;
元方法去类表里继续查找，若依然找不到，再触发类表的&lt;code&gt;__index&lt;/code&gt;元方法，一路找下去。&lt;br /&gt;
找到之后，就把实例表、实参传入这个函数，于是函数内就能访问到成员变量了&lt;/li&gt;
  &lt;li&gt;语法糖&lt;code&gt;instance.method(argument)&lt;/code&gt;&lt;br /&gt;
原型为&lt;code&gt;instance[&apos;method&apos;](argument)&lt;/code&gt;&lt;br /&gt;
这相当于其它语言中调用&lt;code&gt;static&lt;/code&gt;成员函数，没有成员变量传入函数。&lt;br /&gt;
或者&lt;code&gt;class:method(argument)&lt;/code&gt;类表会被传入函数，&lt;br /&gt;
static 成员变量应该存放在类表里，并且可以被 static 成员函数访问&lt;/li&gt;
  &lt;li&gt;上面的 class 指代一个类表，在 cocos 中，class 是一个全局函数，由 cocos 引擎提供。&lt;br /&gt;
这个函数的作用是返回一个新的类表，并为其设置好：元方法&lt;code&gt;__index&lt;/code&gt;（去父类中查找）、&lt;br /&gt;
static 成员函数&lt;code&gt;create&lt;/code&gt;（创建实例对象）、static 成员函数&lt;code&gt;new&lt;/code&gt;（创建实例对象）、&lt;br /&gt;
一般成员函数&lt;code&gt;ctor&lt;/code&gt;（在实例对象中放入初始内容）。&lt;br /&gt;
实例对象可能是&lt;code&gt;table&lt;/code&gt;或&lt;code&gt;userdata&lt;/code&gt;，而类一定是&lt;code&gt;table&lt;/code&gt;。&lt;br /&gt;
Cocos 引擎创建&lt;code&gt;userdata&lt;/code&gt;的时候，总是同时创建一个&lt;code&gt;table&lt;/code&gt;，并将二者绑在一起，&lt;br /&gt;
所以可以对&lt;code&gt;userdata&lt;/code&gt;使用&lt;code&gt;table&lt;/code&gt;语法&lt;/li&gt;
  &lt;li&gt;上面说的语法糖，不止用于函数调用，也用于函数定义：
    &lt;pre&gt;&lt;code class=&quot;language-lua&quot;&gt;local class = {}
function class:ctor(sth)
self.field = sth
end
--等价于：
local class = {}
function class.ctor(self, sth)
self.field = sth
end
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;其它&quot;&gt;其它&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;lua 中任意类型的值都可以代表真假。只有&lt;code&gt;nil&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;两个值代表假，其它值都代表真。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;and&lt;/code&gt;和&lt;code&gt;or&lt;/code&gt;运算符，不会把它们所连接的表达式转成&lt;code&gt;boolean&lt;/code&gt;型，这一点跟其他语言不同。&lt;br /&gt;
&lt;code&gt;a and b or c&lt;/code&gt;与其它语言的 &lt;code&gt;a ? b : c&lt;/code&gt;功能类似，具体是：若 a 和 b 为真，则返回 b；&lt;br /&gt;
若 a 为假，则返回 c。若 a 为真，b 为假，则返回 c，这与&lt;code&gt;?:&lt;/code&gt;不同。&lt;/li&gt;
  &lt;li&gt;参考手册 https://www.lua.org/manual/5.1/&lt;/li&gt;
  &lt;li&gt;https://learnxinyminutes.com/docs/zh-cn/lua-cn/&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 30 Apr 2022 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/lua</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/lua</guid>
        
        
        <category>lua</category>
        
      </item>
    
      <item>
        <title>AI数学基础-信息论</title>
        <description>&lt;p&gt;信息论使用&lt;code&gt;信息熵&lt;/code&gt;的概念，对单个信号源的信息量和通讯中传递的信息的数量与效率等问题做出了解释，
并在世界的不确定性和信息的可测量性之间搭起一座桥梁。
&lt;code&gt;熵&lt;/code&gt;表示一个系统内在的混乱程度。&lt;/p&gt;

&lt;p&gt;事件$A$发生的概率为$p(A)$，则这个事件的&lt;code&gt;自信息量&lt;/code&gt;定义为
\(h(A) = -\log_2p(A)\)&lt;/p&gt;

&lt;p&gt;根据单个事件的自信息量可以计算出包含多个符号的信源的&lt;code&gt;信息熵&lt;/code&gt;。信源的信息熵是信源可能发出的各个符号的自信息量在信源构成的概率空间上的统计平均值。
如果一个信源$X$包含$n$个符号，每个符号$a_i$的取值为$p(a_i)$，则$X$的信源熵为
\(H(X) = -\sum_{i=1}^np(a_i)\log_2p(a_i)\)
信源熵描述了信源每发送一个符号所提供的平均信息量，是信源总体信息测度的均值。当信源中的每个符号的取值概率相等时，信源熵取到最大值$\log_2​n$，意味着信源的随机程度最高。&lt;/p&gt;

&lt;p&gt;在概率论中有&lt;code&gt;条件概率&lt;/code&gt;的概念，将条件概率扩展到信息论中，就可以得到&lt;code&gt;条件熵&lt;/code&gt;。如果两个信源之间具有相关性，那么在已知其中一个信源$X$的条件下，另一个信源$Y$的信源熵就会减小。
条件熵$H(Y∣X)$表示的是在已知随机变量$X$的条件下另一个随机变量$Y$的不确定性，也就是在给定$X$时，根据$Y$的条件概率计算出的熵再对$X$求解数学期望：&lt;/p&gt;

\[H(Y|X) = \sum_{i=1}^np(x_i)H(Y|X=x_i) \\
= -\sum_{i=1}^np(x_i)\sum_{j=1}^mp(y_j|x_i)\log_2p(y_j|x_i) \\
= -\sum_{i=1}^n\sum_{j=1}^mp(x_i,y_j)\log_2p(y_j|x_i)\]

&lt;p&gt;条件熵的意义在于先按照变量$X$的取值对变量$Y$进行了一次分类，对每个分出来的类别计算其单独的信息熵，再将每个类的信息熵按照$X$的分布计算其数学期望。分类带来不确定性下降。&lt;/p&gt;

&lt;p&gt;定义了条件信息熵后，就可以进一步得到&lt;code&gt;互信息&lt;/code&gt;的概念
\(I(X;Y) = H(Y)-H(Y|X)\)
互信息等于$Y$的信源熵减去已知$X$时$Y$的条件熵，即由$X$提供的关于$Y$的不确定性的消除，也可以看成是$X$给$Y$带来的&lt;code&gt;信息增益&lt;/code&gt;。互信息这个名称在通信领域经常使用，信息增益则在机器学习领域中经常使用，两者的本质是一样的。&lt;/p&gt;

&lt;p&gt;在机器学习中，信息增益常常被用于分类特征的选择。对于给定的训练数据集$Y$，$H(Y)$表示在未给定任何特征时，对训练集进行分类的不确定性；$H(Y∣X)$则表示了使用特征$X$对训练集$Y$进行分类的不确定性。信息增益表示的就是特征$X$带来的对训练集$Y$分类不确定性的减少程度，也就是特征$X$对训练集$Y$的区分度。&lt;/p&gt;

&lt;p&gt;显然，信息增益更大的特征具有更强的分类能力。但信息增益的值很大程度上依赖于数据集的信息熵$H(Y)$，因而并不具有绝对意义。为解决这一问题，研究者又提出了信息增益比的概念，并将其定义为$g(X,Y)=I(X;Y)/H(Y)$。&lt;/p&gt;

&lt;p&gt;在机器学习中经常使用的信息论概念叫作&lt;code&gt;Kullback-Leibler散度&lt;/code&gt;，简称&lt;code&gt;KL散度&lt;/code&gt;。KL散度是描述两个概率分布$P$和$Q$之间的差异的一种方法，其定义为\(D_{KL}​(P∣∣Q)=\sum_{i=1}^n​p(x_i​)\log_2\frac{p(x_i​)}{​q(x_i​)}\)​&lt;/p&gt;

&lt;p&gt;信息论中还有一个重要定理，叫作“最大熵原理”。&lt;code&gt;最大熵原理&lt;/code&gt;是确定随机变量统计特性时力图最符合客观情况的一种准则。对于一个未知的概率分布，最坏的情况就是它以等可能性取到每个可能的取值。这个时候的概率分布最均匀，也就是随机变量的随机程度最高，对它进行预测也就最困难。&lt;/p&gt;

&lt;p&gt;将最大熵原理应用到分类问题上就可以得到&lt;code&gt;最大熵模型&lt;/code&gt;。在分类问题中，首先要确定若干特征函数作为分类的依据。为了保证特征函数的有效性，其在模型真实分布$P(X)$上的数学期望和在由训练数据集推导出的经验分布$\widetilde{P}(X)$上的数学期望应该相等，即对给定特征函数数学期望的估计应该是个无偏估计量。&lt;/p&gt;

&lt;p&gt;这样一来，每一个特征函数就对应了一个约束条件。分类的任务就是在这些约束条件下，确定一个最好的分类模型。由于除了这些约束条件之外，没有任何关于分类的先验知识，因而需要利用最大熵原理，求解出不确定性最大的条件分布，即让以下函数的取值最大化\(H(p)=−\sum_{x,y}\widetilde{p}​(x)p(y∣x)\log_2​p(y∣x)\)
式中的$p(y∣x)$就是分类问题要确定的目标条件分布。计算上式的最大值实质上就是一个约束优化问题，由特征函数确定的约束条件可以通过&lt;code&gt;拉格朗日乘子&lt;/code&gt;的引入去除其影响，转化为无约束优化问题。从数学上可以证明，这个模型的解是存在且唯一的。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210816.jpg&quot; alt=&quot;宝贝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 15 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E4%BF%A1%E6%81%AF%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E4%BF%A1%E6%81%AF%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>信息论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-最优化理论</title>
        <description>&lt;p&gt;人工智能的目标是最优化：在复杂环境和多体交互中做出最优决策。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;最优化理论&lt;/code&gt;研究的问题是给定的&lt;code&gt;目标函数&lt;/code&gt;的最大值（最小值）是否存在，并找到令目标函数取到最大值（最小值）的数值。
如果把给定的目标函数看成连绵的山脉，最优化的过程就是判断顶峰的位置并找到到达顶峰路径的过程。
大多数最优化问题都可以通过使目标函数$f(x)$最小化解决，最大化问题则可以通过最小化$−f(x)$实现。
在人工智能和深度学习的应用场景下，只要目标函数的取值足够小，就可以把这个值当作全局最小值使用，作为对性能和复杂度的折中。&lt;/p&gt;

&lt;p&gt;根据约束条件的不同，最优化问题可以分为&lt;code&gt;无约束优化&lt;/code&gt;和&lt;code&gt;约束优化&lt;/code&gt;两类。无约束优化对自变量 x 的取值没有限制，约束优化则把 x 的取值限制在特定的集合内，也就是满足一定的约束条件。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;线性规划&lt;/code&gt;就是一类典型的约束优化，其解决的问题通常是在有限的成本约束下取得最大的收益。约束优化问题通常比无约束优化问题更加复杂，但通过拉格朗日乘子的引入可以将含有$n$个变量和$k$个约束条件的问题转化为含有$(n+k)$个变量的无约束优化问题。&lt;/p&gt;

&lt;p&gt;求解无约束优化问题最常用的方法是&lt;code&gt;梯度下降法&lt;/code&gt;。直观地说，梯度下降法就是沿着目标函数值下降最快的方向寻找最小值，就像爬山时要沿着坡度最陡的路径寻找山顶一样。在数学上，梯度的方向是目标函数导数的反方向。&lt;/p&gt;

&lt;p&gt;如果将二阶导数引入优化过程，得到的典型方法就是牛顿法。在牛顿法中，目标函数首先被泰勒展开，写成二阶近似的形式（相比之下，梯度下降法只保留了目标函数的一阶近似）。此时再对二阶近似后的目标函数求导，并令其导数等于 0，得到的向量表示的就是下降最快的方向。相比于梯度下降法，牛顿法的收敛速度更快。&lt;/p&gt;

&lt;p&gt;不管是利用一阶导数的梯度下降法，还是利用二阶导数的牛顿法，其寻找最小值点的基本思想都是先确定方向，再确定步长，因而统称为&lt;code&gt;线性搜索方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;还有一类算法，其寻找最小值点的基本思路是先确定步长，以步长为参数划定一个区域，再在这个区域内寻找最快下降的方向。这类算法被称为&lt;code&gt;置信域方法&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;相对于传统的基于数学理论的最优化方法，启发式算法显得返璞归真。启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。&lt;/p&gt;

&lt;p&gt;启发式算法的核心思想就是大自然中”优胜劣汰”的生存法则，并在算法的实现中添加了选择和突变等经验因素。事实上，搜索越多并不意味着智能越高，智能高的表现恰恰是能够善用启发式策略，不用经过大量搜索也能解决问题。启发式算法的实例包括模拟生物进化规律的遗传算法、模拟统计物理中固体结晶过程的模拟退火算法、模拟低等动物产生集群智能的蚁群算法等。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210814.jpg&quot; alt=&quot;宝贝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 14 Aug 2021 00:00:00 +0800</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>最优化理论</category>
        
      </item>
    
  </channel>
</rss>
