<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xl000&#39;s blog</title>
    <description>xl000&#39;s blog
</description>
    <link>http://xiaobin0860.github.io/</link>
    <atom:link href="http://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 23 Jan 2016 03:27:14 +0800</pubDate>
    <lastBuildDate>Sat, 23 Jan 2016 03:27:14 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>AutoBuild(3)</title>
        <description>&lt;p&gt;今天svn提交莫名奇妙卡住，提交成功了，但svn命令一直不返回。强关了后cleanup，再更新后就没有更新了。
可见提交其实已经成功。删了重新checkout问题依旧。&lt;/p&gt;

&lt;p&gt;为什么提交成功了命令行却一直不返回呢？忽然想到之前为了做AutoBuild系统，hook了svn提交。提交后用wget
执行了通知编译服务器操作，而编译服务器不在线通知不到，就一直卡在那。&lt;/p&gt;

&lt;p&gt;知道问题原因了，修改wget超时及重试次数，并改为后台运行，搞定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/wget http://xxx --tries=1 --spider --timeout=5 --background
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/autobuild/svn/2016/01/23/autobuild(3).html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/autobuild/svn/2016/01/23/autobuild(3).html</guid>
        
        
        <category>autobuild</category>
        
        <category>svn</category>
        
      </item>
    
      <item>
        <title>分布式服务器设计</title>
        <description>&lt;h2 id=&quot;jone-zhangs-blog----httpwwwcnblogscomccdevp3341234html&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/ccdev/p/3341234.html&quot;&gt;Jone Zhang’s Blog – 高并发服务端分布式系统设计概要&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://xiaobin0860.github.io/imgs/20160121_jone_zhang.jpg&quot; alt=&quot;分布式系统设计图&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由N台机器组合而成，其中Global Master一台，Global Slave一台到多台，两者之间保持强一致性并完全同步，&lt;br /&gt;
可由Global Slave随时顶替Global Master工作，它们被Global Heartbeat（一台）来管理，保证有一个Global Master正常工作；&lt;br /&gt;
Global Heartbeat由于无压力，通常认为其不能挂掉，如果它挂掉了，则必须人工干预才能恢复正常；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由多个groups合成，每一个group负责相应业务的数据的存取，它们是数据节点，是真正抗压力的地方，&lt;br /&gt;
每一个group由一个Group Master和一个到多个Group Slave构成，Group Master作为该group的主节点，提供读和写，&lt;br /&gt;
而Group Slave则只提供读服务且保证这些Group Slave节点中，至少有一个和Group Master保持完全同步，&lt;br /&gt;
剩余的Group Slave和Group Master能够达到最终一致，它们之间以“半同步”模式工作保证最终一致性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的健康状态由Global Master来管理，Global Master向group发送管理信息，并保证有一个Group Master正常工作，&lt;br /&gt;
若Group Master宕机，在该group内通过分布式选举产生新的Group Master顶替原来宕机的机器继续工作，&lt;br /&gt;
但仍然有一小段时间需要中断写服务来切换新的Group Master；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的底层是实际的存储系统，File system，它们是无状态的，即，由分布式选举产生的Group Master可以在原来的File system上继续工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client的上端可认为是Web请求，Client在“首次”进行数据读写时，向Global Master查询相应的group信息，并将其缓存，&lt;br /&gt;
后续将直接与相应的group进行通信；为避免大量“首次”查询冲垮Global Master，在Client与Global Master之间增加DNS负载均衡，&lt;br /&gt;
可由Global Slave分担部分查询工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当Client已经拥有足够的group信息时，它将直接与group通信进行工作，从而真正的压力和流量由各个group分担，并处理完成需要的工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;我的分布式游戏服务器设计&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://xiaobin0860.github.io/imgs/20160121_my_server.jpg&quot; alt=&quot;分布式游戏服务器设计图&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/server/%E5%88%86%E5%B8%83%E5%BC%8F/2016/01/21/server.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/server/%E5%88%86%E5%B8%83%E5%BC%8F/2016/01/21/server.html</guid>
        
        
        <category>server</category>
        
        <category>分布式</category>
        
      </item>
    
      <item>
        <title>redmine</title>
        <description>&lt;ol&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;ruby&quot;&gt;安装ruby&lt;/h2&gt;

    &lt;p&gt;gpg2 –keyserver hkp://keys.gnupg.net –recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
 curl -L https://get.rvm.io | bash -s stable
 source /etc/profile.d/rvm.sh
 rvm list known
 rvm install ruby-head&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;rails&quot;&gt;安装rails&lt;/h2&gt;

    &lt;p&gt;gem install rails&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</description>
        <pubDate>Mon, 18 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/redmine/2016/01/18/redmine.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/redmine/2016/01/18/redmine.html</guid>
        
        
        <category>redmine</category>
        
      </item>
    
      <item>
        <title>jekyll templates</title>
        <description>&lt;h2 id=&quot;variables&quot;&gt;Variables&lt;/h2&gt;

&lt;p&gt;Variables are surrounded by &lt;code class=&quot;highlighter-rouge&quot;&gt;\{\{&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;}}&lt;/code&gt; like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;My first name is \{\{ first_name  }}. My last name is \{\{ last_name  }}.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;tags&quot;&gt;Tags&lt;/h2&gt;

&lt;p&gt;Tags provide arbitrary logic in the rendering process.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\{\% if user.is_authenticated %}Hello, \{\{ user.username  }}.\{\% endif %}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;filters&quot;&gt;Filters&lt;/h2&gt;

&lt;p&gt;Filters transform the values of variables and tag arguments.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\{\{ site.time | date_to_xmlschema  }}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;comments&quot;&gt;Comments&lt;/h2&gt;

&lt;p&gt;Comments look like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\{\# this won&#39;t be rendered #}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://xiaobin0860.github.io/imgs/20160117.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 17 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/jekyll/2016/01/17/jekyll-templates.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/jekyll/2016/01/17/jekyll-templates.html</guid>
        
        
        <category>jekyll</category>
        
      </item>
    
      <item>
        <title>Auto-Refresh code in HTML</title>
        <description>&lt;h2 id=&quot;use-meta-tag&quot;&gt;use meta tag&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&amp;gt;
Please within the `head` tag of your html document, this `meta` tag  
will instruct the browser to refresh every `5` seconds.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;AutoBuild系统中我想有个页面能够一直看到当前项目的状态，先用着这个方法去定时查询。
以后看有没有办法实现通知。^_^&lt;/p&gt;

&lt;h2 id=&quot;click-to-refresh&quot;&gt;click to refresh&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;body onclick=&quot;window.location.reload();&quot;&amp;gt;
    ...
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;scroll-to-bottom&quot;&gt;scroll to bottom&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;window.scrollTo(0, document.body.scrollHeight);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://xiaobin0860.github.io/imgs/20160116.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 16 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/html/2016/01/16/html-auto-refresh.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/html/2016/01/16/html-auto-refresh.html</guid>
        
        
        <category>html</category>
        
      </item>
    
      <item>
        <title>erlang/opt doc</title>
        <description>&lt;p&gt;&lt;a href=&quot;http://xiaobin0860.github.io/otp_doc/doc/index.html&quot;&gt;erlang/opt doc&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/erlang/2016/01/12/otp-doc.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/erlang/2016/01/12/otp-doc.html</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>erlang执行shell</title>
        <description>&lt;h2 id=&quot;oscmdcmd&quot;&gt;os:cmd(Cmd)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmd(Command) -&amp;gt; string()
Types:
Command = atom() | io_lib:chars()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;erlangopenportportname-portsettings&quot;&gt;erlang:open_port(PortName, PortSettings)&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open_port(PortName, PortSettings) -&amp;gt; port()
Types:
PortName = 
    {spawn, Command :: string() | binary()} |
    {spawn_driver, Command :: string() | binary()} |
    {spawn_executable, FileName :: file:name()} |
    {fd, In :: integer() &amp;gt;= 0, Out :: integer() &amp;gt;= 0}
PortSettings = [Opt]
Opt = 
    {packet, N :: 1 | 2 | 4} |
    stream |
    {line, L :: integer() &amp;gt;= 0} |
    {cd, Dir :: string() | binary()} |
    {env, Env :: [{Name :: string(), Val :: string() | false}]} |
    {args, [string() | binary()]} |
    {arg0, string() | binary()} |
    exit_status |
    use_stdio |
    nouse_stdio |
    stderr_to_stdout |
    in |
    out |
    binary |
    eof |
    {parallelism, Boolean :: boolean()} |
    hide
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;example&quot;&gt;Example&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;loop2() -&amp;gt;
    receive
        {build} -&amp;gt;
            io:format(&quot;build ...~n&quot;),
            Port = open_port({spawn_executable, &quot;path/build_ios_nolog.sh&quot;}, [stream, exit_status, eof, hide]),
            Result = get_data(Port, []),
            io:format(&quot;~p~n&quot;, [Result]),
            loop2();
        stop -&amp;gt;
            ok;
        _ -&amp;gt;
            io:format(&quot;recv unknown message!~n&quot;),
            loop2()
    end.

get_data(Port, Sofar) -&amp;gt;
    receive
        {Port, {data, Bytes}} -&amp;gt;
            get_data(Port, [Sofar|Bytes]);
        {Port, eof} -&amp;gt;
            Port ! {self(), close},
            receive
                {Port, closed} -&amp;gt; true
            end,
            receive
                {&#39;EXIT&#39;,  Port,  _} -&amp;gt; ok
            after 1 -&amp;gt; ok
            end,
            ExitCode =
            receive
                {Port, {exit_status, Code}} -&amp;gt; Code
            end,
            {ExitCode, lists:flatten(Sofar)}
            %{ExitCode, Sofar}
    end.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/erlang/2016/01/12/erlang-shell.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/erlang/2016/01/12/erlang-shell.html</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>记录一次内存错误debug</title>
        <description>&lt;p&gt;项目在某页面崩溃，ide断在EventDispatcher::cleanToRemovedListeners()。
据断点处信息_toRemovedListeners里有的值retaincount已经为0了，一定是多释放了。
但找半天没找到哪些地方用的不对，都是在onEnter里添加监听，在onExit里取消监听。
去到2dx里代码仓库看最新的提交也没发现有修复类似bug的，应该还是自己代码的原因。
最后没办法了，在所有代码使用listener的地方，添加时先retain，remove时再release。
改着改着就发现一个自定义控件的一个方法在remove里没把listener指针置空，导致onExit时
又释放了一遍。再回头看崩溃页面，果然用到过这个控件。我*&lt;/p&gt;

&lt;p&gt;这种内存错误bug最难调了，崩溃时有效信息不多，而且不一定在什么时候、什么地方才会表现出来。
写代码时一定要注意，指针释放后置空。&lt;/p&gt;

</description>
        <pubDate>Mon, 11 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/cocos2d-x/debug/2016/01/11/2dx-debug.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/cocos2d-x/debug/2016/01/11/2dx-debug.html</guid>
        
        
        <category>cocos2d-x</category>
        
        <category>debug</category>
        
      </item>
    
      <item>
        <title>My first post</title>
        <description>&lt;p&gt;Stay hungry, Stay foolish.&lt;br /&gt;
求知若饥，虚心若愚。&lt;br /&gt;
2016.1.10&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://xiaobin0860.github.io/imgs/20160110.jpg&quot; alt=&quot;小宝&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Jan 2016 21:04:46 +0800</pubDate>
        <link>http://xiaobin0860.github.io/jekyll/update/2016/01/10/fist-post.html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/jekyll/update/2016/01/10/fist-post.html</guid>
        
        
        <category>jekyll</category>
        
        <category>update</category>
        
      </item>
    
      <item>
        <title>AutoBuild(2)</title>
        <description>&lt;h2 id=&quot;websocket&quot;&gt;Websocket&lt;/h2&gt;

&lt;p&gt;WebSocket is an HTML5 technology used for two-way messaging from inside a web page.&lt;br /&gt;
WebSocket is a protocol providing full-duplex communication channels over a single TCP connection.&lt;br /&gt;
&lt;a href=&quot;https://en.wikipedia.org/wiki/WebSocket&quot;&gt;WebSocket&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;chicagoboss-websockets&quot;&gt;ChicagoBoss WebSockets&lt;/h2&gt;

&lt;h3 id=&quot;server-code&quot;&gt;Server Code&lt;/h3&gt;

&lt;p&gt;The server WebSocket API is based around Erlang message-passing;&lt;br /&gt;
to send a message to a particular client, simply send it a message like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WebSocket ! {text, &amp;lt;&amp;lt;&quot;some text&quot;&amp;gt;&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Furthermore, you can broadcast a message that will be handled by your &lt;code class=&quot;highlighter-rouge&quot;&gt;handle_broadcast/2&lt;/code&gt; function by&lt;br /&gt;
using the module name of your websocket module and the proper method of the &lt;code class=&quot;highlighter-rouge&quot;&gt;boss_service_worker&lt;/code&gt; module:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boss_service_worker:broadcast(myapp_myservice_websocket, MyMessage).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;To handle incoming messages from clients, you’ll need to create WebSocket controllers in your project’s&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;src/websocket&lt;/code&gt; directory. Each controller module should have a name of the form&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;app name&amp;gt;_&amp;lt;service name&amp;gt;_websocket.erl&lt;/code&gt; and be a parameterized module with parameters for&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;Req&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;SessionId&lt;/code&gt;, e.g.:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-module(myapp_myservice_websocket, [Req, SessionId]).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The module should implement the &lt;code class=&quot;highlighter-rouge&quot;&gt;boss_service_handler&lt;/code&gt; behavior.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-module(ab_status_websocket, [Req, SessionId]).
-behaviour(boss_service_handler).
-compile(export_all).

init() -&amp;gt; {ok, []}.

handle_join(_Url, WebsocketPid, State) -&amp;gt;
    log:d(&quot;~p joined!&quot;, [WebsocketPid]),
    WebsocketPid ! {text, &quot;Hello WebSocket!&quot;},
    NewState = [WebsocketPid | State],
    {noreply, NewState}.

handle_close(_Reason, _Url, WebsocketPid, State) -&amp;gt;
    log:d(&quot;~p closed!&quot;, [WebsocketPid]),
    NewState = lists:delete(WebsocketPid, State),
    {noreply, NewState}.

handle_incoming(_Url, _WebsocketPid, _Message, State) -&amp;gt;
    {noreply, State}.

handle_broadcast(Message, State) -&amp;gt;
    broadcast_message(Message, State),
    {noreply, State}.

handle_info(_Info, State) -&amp;gt;
    {noreply, State}.

terminate(_Reason, _State) -&amp;gt; ok.

broadcast_message(Message, [H|R]) -&amp;gt;
    log:d(&quot;send ~p to ~p ...&quot;, [Message, H]),
    H ! {text, Message},
    broadcast_message(Message, R);
broadcast_message(_Message, []) -&amp;gt; ok.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;client-code&quot;&gt;Client code&lt;/h3&gt;

&lt;p&gt;WebSocket URLs are automatically generated from the WebSocket controllers in your project’s&lt;br /&gt;
src/websocket directory. For example, if you have &lt;code class=&quot;highlighter-rouge&quot;&gt;myapp_foobar_websocket.erl&lt;/code&gt;, then to create&lt;br /&gt;
a new WebSocket on the client:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;
    &amp;lt;!--&amp;lt;meta http-equiv=&quot;refresh&quot; content=&quot;5&quot;&amp;gt;--&amp;gt;
    &amp;lt;script&amp;gt;
        function createWebsocket()
        {
            ws = new WebSocket(&quot;ws://localhost:8001/websocket/status&quot;);
            ws.onmessage = function(e){
                &amp;lt;!--alert(e.data);--&amp;gt;
                document.getElementById(&quot;status&quot;).innerHTML = e.data;
                scrollToBottom();
            }
        }
        function scrollToBottom()
        {
            window.scrollTo(0, document.body.scrollHeight);
        }
        function reloadPage()
        {
            window.location.reload();
        }
        function load()
        {
            scrollToBottom();
            createWebsocket();
        }
    &amp;lt;/script&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;!--&amp;lt;body bgcolor=&quot;#000000&quot; onclick=&quot;reloadPage()&quot; onload=&quot;load()&quot;&amp;gt;--&amp;gt;
&amp;lt;body bgcolor=&quot;#000000&quot; onload=&quot;load()&quot;&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;pre style=&quot;color:#00ff00&quot; id=&quot;status&quot;&amp;gt;
    
    &amp;lt;/pre&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此AutoBuild初步完成状态通知。&lt;/p&gt;

</description>
        <pubDate>Fri, 08 Jan 2016 00:00:00 +0800</pubDate>
        <link>http://xiaobin0860.github.io/erlang/autobuild/chicagoboss/websocket/2016/01/08/autobuild(2).html</link>
        <guid isPermaLink="true">http://xiaobin0860.github.io/erlang/autobuild/chicagoboss/websocket/2016/01/08/autobuild(2).html</guid>
        
        
        <category>erlang</category>
        
        <category>autobuild</category>
        
        <category>chicagoboss</category>
        
        <category>websocket</category>
        
      </item>
    
  </channel>
</rss>
