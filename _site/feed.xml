<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 17 Jun 2016 00:23:01 +0800</pubDate>
    <lastBuildDate>Fri, 17 Jun 2016 00:23:01 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Learn You Some Erlang(6)</title>
        <description>&lt;h2 id=&quot;concurrency&quot;&gt;Concurrency&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;start new process, &lt;code&gt;spawn/1&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;G = fun(X) -&amp;gt; timer:sleep(X), io:format(“~p~n”, [X]) end.
 [spawn(fun(X) -&amp;gt; G(X) end) || X &amp;lt;= list:seq(1,10)].&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;send message&lt;/p&gt;

    &lt;p&gt;self() ! self() ! double&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;receive message&lt;/p&gt;

    &lt;p&gt;receive
     Pattern1 when Guard1 -&amp;gt; Expr1;
     Partern2 when Guard2 -&amp;gt; Expr2;
     _ -&amp;gt; Expr3
 end.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Thu, 16 Jun 2016 00:00:00 +0800</pubDate>
        <link>/LYSE</link>
        <guid isPermaLink="true">/LYSE</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>Learn You Some Erlang(5)</title>
        <description>&lt;h2 id=&quot;recursion&quot;&gt;Recursion&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Fac&lt;/p&gt;

    &lt;p&gt;fac(0) -&amp;gt; 1;
  fac(N) when N &amp;gt; 0 -&amp;gt; N*fac(N-1).&lt;/p&gt;

    &lt;p&gt;tail_fac(N) -&amp;gt; tail_fac(N, 1).
  tail_fac(0, Fac) -&amp;gt; Fac;
  tail_fac(N, Fac) when N&amp;gt;0 -&amp;gt; tail_fac(N-1, N*Fac).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Len
  len([]) -&amp;gt; 0;
  len([_|T]) -&amp;gt; 1 + len(T).&lt;/p&gt;

    &lt;p&gt;tail_len(L) -&amp;gt; tail_len(L,0).
  tail_len([], Acc) -&amp;gt; Acc;
  tail_len([_|T], Acc) -&amp;gt; tail_len(T,Acc+1).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;higher-order-functions&quot;&gt;Higher Order Functions&lt;/h2&gt;

&lt;p&gt;pass functions from outside a module&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun Module:Function/Arity

map(_, []) -&amp;gt; [];
map(F, [H|T]) -&amp;gt; [F(H)|map(F,T)].
incr(X) -&amp;gt; X + 1.
decr(X) -&amp;gt; X - 1.

1&amp;gt; c(hhfuns).
{ok, hhfuns}
2&amp;gt; L = [1,2,3,4,5].
[1,2,3,4,5]
3&amp;gt; hhfuns:increment(L).
[2,3,4,5,6]
4&amp;gt; hhfuns:decrement(L).
[0,1,2,3,4]
5&amp;gt; hhfuns:map(fun hhfuns:incr/1, L).
[2,3,4,5,6]
6&amp;gt; hhfuns:map(fun hhfuns:decr/1, L).
[0,1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 22 Feb 2016 00:00:00 +0800</pubDate>
        <link>/LYSE</link>
        <guid isPermaLink="true">/LYSE</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>Learn You Some Erlang(4)</title>
        <description>&lt;h2 id=&quot;bit-syntax&quot;&gt;Bit Syntax!&lt;/h2&gt;

&lt;p&gt;Bit syntax encloses binary data between « and »,
splits it in readable segments, and each segment is separated by a comma.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1&amp;gt; Color = 16#F09A29.
15768105
2&amp;gt; Pixel = &amp;lt;&amp;lt;Color:24&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;240,154,41&amp;gt;&amp;gt;
3&amp;gt; Pixels = &amp;lt;&amp;lt;213,45,132,64,76,32,76,0,0,234,32,15&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;213,45,132,64,76,32,76,0,0,234,32,15&amp;gt;&amp;gt;
4&amp;gt; &amp;lt;&amp;lt;Pix1,Pix2,Pix3,Pix4&amp;gt;&amp;gt; = Pixels.
** exception error: no match of right hand side value 
5&amp;gt; &amp;lt;&amp;lt;Pix1:24, Pix2:24, Pix3:24, Pix4:24&amp;gt;&amp;gt; = Pixels.
&amp;lt;&amp;lt;213,45,132,64,76,32,76,0,0,234,32,15&amp;gt;&amp;gt;
6&amp;gt; &amp;lt;&amp;lt;R:8, G:8, B:8&amp;gt;&amp;gt; = &amp;lt;&amp;lt;Pix1:24&amp;gt;&amp;gt;.
&amp;lt;&amp;lt;213,45,132&amp;gt;&amp;gt;
7&amp;gt; R.
213
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;modules&quot;&gt;Modules&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;What are modules&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Modules are a bunch of functions regrouped in a single file,
under a single name. Additionally, all functions in Erlang must be defined in modules.
Function defined in a module needs to be called with the form &lt;code&gt;Module:Function(Arguments).&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Module Declaration&lt;/p&gt;

    &lt;p&gt;-module(Name).
  -export([Function1/Arity, Function2/Arity, …, FunctionN/Arity]).
  -Name(Attribute).   #-compile([debug_info, export_all]).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Compiling the code&lt;/p&gt;

    &lt;p&gt;$ erlc flags file.erl&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;syntax-in-functions&quot;&gt;Syntax in functions&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pattern Matching&lt;/p&gt;

    &lt;p&gt;greet(male, Name) -&amp;gt;
  io:format(“Hello, Mr. ~s!”, [Name]);
  greet(female, Name) -&amp;gt;
  io:format(“Hello, Mrs. ~s!”, [Name]);
  greet(_, Name) -&amp;gt;
  io:format(“Hello, ~s!”, [Name]).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Guards&lt;/p&gt;

    &lt;p&gt;right_age(X) when X &amp;gt;= 16, X =&amp;lt; 104 -&amp;gt;
  true;
  right_age(_) -&amp;gt;
  false.&lt;/p&gt;

    &lt;p&gt;is_atom/1           is_binary/1 
  is_bitstring/1      is_boolean/1        is_builtin/3 
  is_float/1          is_function/1       is_function/2 
  is_integer/1        is_list/1           is_number/1 
  is_pid/1            is_port/1           is_record/2 
  is_record/3         is_reference/1      is_tuple/1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;If&lt;/p&gt;

    &lt;p&gt;%% note, this one would be better as a pattern match in function heads!
  %% I’m doing it this way for the sake of the example.
  help_me(Animal) -&amp;gt;
      Talk = if Animal == cat  -&amp;gt; “meow”;
          Animal == beef -&amp;gt; “mooo”;
          Animal == dog  -&amp;gt; “bark”;
          Animal == tree -&amp;gt; “bark”;
          true -&amp;gt; “fgdadfgna”
      end,
      {Animal, “says “ ++ Talk ++ “!”}.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Case&lt;/p&gt;

    &lt;p&gt;beach(Temperature) -&amp;gt;
      case Temperature of
          {celsius, N} when N &amp;gt;= 20, N =&amp;lt; 45 -&amp;gt;
              ‘favorable’;
          {kelvin, N} when N &amp;gt;= 293, N =&amp;lt; 318 -&amp;gt;
              ‘scientifically favorable’;
          {fahrenheit, N} when N &amp;gt;= 68, N =&amp;lt; 113 -&amp;gt;
              ‘favorable in the US’;
          _ -&amp;gt;
              ‘avoid beach’
      end.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 21 Feb 2016 00:00:00 +0800</pubDate>
        <link>/LYSE</link>
        <guid isPermaLink="true">/LYSE</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>Learn You Some Erlang(3)</title>
        <description>&lt;h2 id=&quot;lists&quot;&gt;Lists&lt;/h2&gt;

&lt;p&gt;Lists can contain anything! &lt;code&gt;[Element1, Element2, ..., ElementN]&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1&amp;gt; [1, 2, 3, {numbers,[4,5,6]}, 5.34, atom].
[1,2,3,{numbers,[4,5,6]},5.34,atom]

2&amp;gt; [97, 98, 99].
&quot;abc&quot;

[New] ++ [OldList]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;BIFS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hd([1,2,3,4]).
tl([1,2,3,4]).
length(List).
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pattern matching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Head|Tail].
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Tue, 16 Feb 2016 00:00:00 +0800</pubDate>
        <link>/LYSE</link>
        <guid isPermaLink="true">/LYSE</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>Learn You Some Erlang(2)</title>
        <description>&lt;p&gt;不用找(1)了，记本上了^_^&lt;/p&gt;

&lt;h2 id=&quot;tuples&quot;&gt;Tuples&lt;/h2&gt;

&lt;p&gt;A tuple is a way to organize data. It’s a way to group togeter many terms 
when you known how many there are.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{Element1, Element2, ..., ElementN}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常使用&lt;code&gt;tagged tuple&lt;/code&gt;, 例如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Temperature = {celsius, 23.213}.
Point = {point, {1, 2}}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;取值&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{celsius, T} = Temperature.
{point, {X, _}} = Point.
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 15 Feb 2016 00:00:00 +0800</pubDate>
        <link>/LYSE</link>
        <guid isPermaLink="true">/LYSE</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>chicagoboss return json</title>
        <description>&lt;p&gt;return &lt;code&gt;{json, Data::proplist()}&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-module(hhs_realtor_controller, [Req]).
-compile(export_all).
-include(&quot;hhs_config.hrl&quot;).

register(&#39;POST&#39;, []) -&amp;gt;
    log:d(&quot;register post_params: ~p&quot;, [Req:post_params()]),
    Phone = Req:post_param(&quot;phone&quot;),
    Pass = Req:post_param(&quot;pass&quot;),
    log:d(&quot;register: phone=~p, pass=~p&quot;, [Phone, Pass]),
    case boss_db:find(realtor, [phone, equals, Phone]) of
        [_SavedRealtor] -&amp;gt;
            log:w(&quot;realtor with phone ~p already exists!&quot;, [Phone]),
            {json, [{success, false}, {message, &quot;already exists!&quot;}]};
        [] -&amp;gt;
            log:d(&quot;create new realotr: phone=~p, pass=~p&quot;, [Phone, Pass]),
            NewRealtor = realtor:new(id, Phone, &quot;&quot;, user_lib:hash_password(Pass), &quot;&quot;, &quot;&quot;),
            case NewRealtor:save() of   %{ok, SavedBossRecord} | {error, [ErrorMessages]}
                {ok, Saved} -&amp;gt;
                    %{json, #result{success=true, json=Saved}};
                    {json, [{success, true}, {realtor, Saved}]};
                {error, [Errors]} -&amp;gt;
                    {json, [{success, false}, {message, Errors}]}
            end
    end.

login(&#39;POST&#39;, []) -&amp;gt;
    log:d(&quot;login post_params: ~p&quot;, [Req:post_params()]),
    Phone = Req:post_param(&quot;phone&quot;),
    Pass = Req:post_param(&quot;pass&quot;),
    log:d(&quot;login: phone=~p, pass=~p&quot;, [Phone, Pass]),
    case boss_db:find(realtor, [phone, equals, Phone]) of
        [SavedRealtor] -&amp;gt;
            case SavedRealtor:check_password(Pass) of
                true -&amp;gt;
                    %{json, #result{success=true, json=SavedRealtor}};
                    {json, [{success, true}, {realtor, SavedRealtor}]};
                false -&amp;gt;
                    %{json, #result{success=false, message=&quot;wrong password&quot;}}
                    {json, [{success, false}, {message, &quot;wrong password&quot;}]}
            end;
        [] -&amp;gt;
            log:w(&quot;realtor with phone ~p not exists!&quot;, [Phone]),
            {json, [{success, false}, {message, &quot;no account&quot;}]}
    end.
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 05 Feb 2016 00:00:00 +0800</pubDate>
        <link>/chicagoboss-json</link>
        <guid isPermaLink="true">/chicagoboss-json</guid>
        
        
        <category>chicagoboss</category>
        
      </item>
    
      <item>
        <title>erlang gen tcp</title>
        <description>&lt;pre&gt;&lt;code&gt;connect(Address, Port, Options) -&amp;gt; {ok, Socket} | {error, Reason}
connect(Address, Port, Options, Timeout) -&amp;gt;
    {ok, Socket} | {error, Reason}

    Types:

        Address = inet:ip_address() | inet:hostname()
        Port = inet:port_number()
        Options = [connect_option()]
        Timeout = timeout()
        Socket = socket()
        Reason = inet:posix()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;client() -&amp;gt;
    SomeHostInNet = &quot;localhost&quot;, % to make it runnable on one machine
    {ok, Sock} = gen_tcp:connect(SomeHostInNet, 5678, [binary, {packet, 0}]),
    ok = gen_tcp:send(Sock, &quot;Some Data&quot;),
    ok = gen_tcp:close(Sock).

server() -&amp;gt;
    {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 0}, {active, false}]),
    {ok, Sock} = gen_tcp:accept(LSock),
    {ok, Bin} = do_recv(Sock, []),
    ok = gen_tcp:close(Sock),
    Bin.

do_recv(Sock, Bs) -&amp;gt;
    case gen_tcp:recv(Sock, 0) of
        {ok, B} -&amp;gt;
            do_recv(Sock, [Bs, B]);
        {error, closed} -&amp;gt;
            {ok, list_to_binary(Bs)}
    end.
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 29 Jan 2016 00:00:00 +0800</pubDate>
        <link>/gen_tcp</link>
        <guid isPermaLink="true">/gen_tcp</guid>
        
        
        <category>erlang</category>
        
      </item>
    
      <item>
        <title>shared ptr</title>
        <description>&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;thread&amp;gt;
#include &amp;lt;memory&amp;gt;
#include &amp;lt;chrono&amp;gt;
#include &amp;lt;atomic&amp;gt;

using Lock = std::lock_guard&amp;lt;std::mutex&amp;gt;;

static std::atomic&amp;lt;int&amp;gt; s_test_count(3);
class Demo;
using DemoPtr = std::shared_ptr&amp;lt;Demo&amp;gt;;
class Demo : public std::enable_shared_from_this&amp;lt;Demo&amp;gt;
{
public:
    Demo()
    : _testValue(0)
    , _atomicValue(0)
    {
        
    }
    
    ~Demo()
    {
        std::cout &amp;lt;&amp;lt; &quot;~Demo()&quot; &amp;lt;&amp;lt; std::endl;
    }
    
    void test1()
    {
        std::thread t([this]{
            std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
            
            --s_test_count;
        });
        t.detach();
        {
            Lock l(_testValueMutex);
            ++_testValue;
        }
        std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
    }
    
    void test2()
    {
        {
            auto ptr = shared_from_this();
            std::thread t([this, ptr]{
                std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
                std::this_thread::sleep_for(std::chrono::seconds(1));
                {
                    Lock l(_testValueMutex);
                    ++_testValue;
                }
                std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
                
                --s_test_count;
            });
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }
    
    void test3()
    {
        {
            std::thread t(std::bind(&amp;amp;Demo::_theadFunc, this));
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }
    
    void test4()
    {
        {
            std::thread t(std::bind(&amp;amp;Demo::_theadFunc, shared_from_this()));
            t.detach();
            {
                Lock l(_testValueMutex);
                ++_testValue;
            }
            std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        }
    }

    void test5()
    {
        auto ptr = shared_from_this();
        for (auto j=0; j&amp;lt;20; ++j) {
            std::thread t([this, ptr]{
                std::this_thread::sleep_for(std::chrono::seconds(1));
                ++_atomicValue;
                std::cerr &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
            });
            t.detach();
        }
        while (_atomicValue != 20) {
            std::this_thread::yield();
        }
        --s_test_count;
    }
private:
    std::mutex _testValueMutex;
    int _testValue;
    std::atomic&amp;lt;int&amp;gt; _atomicValue;
    
    void _theadFunc()
    {
        std::cout &amp;lt;&amp;lt; &quot;thead&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot; func begin ...&quot; &amp;lt;&amp;lt; std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(1));
        {
            Lock l(_testValueMutex);
            ++_testValue;
        }
        std::cout &amp;lt;&amp;lt; &quot;thread&quot; &amp;lt;&amp;lt; std::this_thread::get_id() &amp;lt;&amp;lt; &quot;: value=&quot; &amp;lt;&amp;lt; _testValue &amp;lt;&amp;lt; std::endl;
        
        --s_test_count;
    }
};

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout &amp;lt;&amp;lt; &quot;Hello, World!\n&quot;;
//	{
//		// test 1 crash
//		auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
//		std::cout &amp;lt;&amp;lt; &quot;Before test1: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//		demoPtr-&amp;gt;test1();
//		std::cout &amp;lt;&amp;lt; &quot;After test1: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//	}
    {
        //test 2
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test2: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test2();
        std::cout &amp;lt;&amp;lt; &quot;After test2: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
//	{
//		//test 3 crash
//		auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
//		std::cout &amp;lt;&amp;lt; &quot;Before test3: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//		demoPtr-&amp;gt;test3();
//		std::cout &amp;lt;&amp;lt; &quot;After test3: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
//	}
    {
        //test 4
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test4: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test4();
        std::cout &amp;lt;&amp;lt; &quot;After test4: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
    {
        //test 5
        auto demoPtr = std::make_shared&amp;lt;Demo&amp;gt;();
        std::cout &amp;lt;&amp;lt; &quot;Before test5: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
        demoPtr-&amp;gt;test5();
        std::cout &amp;lt;&amp;lt; &quot;After test5: use_count=&quot; &amp;lt;&amp;lt; demoPtr.use_count() &amp;lt;&amp;lt; std::endl;
    }
    
    while (s_test_count &amp;gt; 0) {
        std::this_thread::yield();
    }
    
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>/c++shared_ptr</link>
        <guid isPermaLink="true">/c++shared_ptr</guid>
        
        
        <category>c++</category>
        
        <category>shared_ptr</category>
        
        <category>atomic</category>
        
      </item>
    
      <item>
        <title>AutoBuild(3)</title>
        <description>&lt;p&gt;今天svn提交莫名奇妙卡住，提交成功了，但svn命令一直不返回。强关了后cleanup，再更新后就没有更新了。
可见提交其实已经成功。删了重新checkout问题依旧。&lt;/p&gt;

&lt;p&gt;为什么提交成功了命令行却一直不返回呢？忽然想到之前为了做AutoBuild系统，hook了svn提交。提交后用wget
执行了通知编译服务器操作，而编译服务器不在线通知不到，就一直卡在那。&lt;/p&gt;

&lt;p&gt;知道问题原因了，修改wget超时及重试次数，并改为后台运行，搞定。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/wget http://xxx --tries=1 --spider --timeout=5 --background
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 23 Jan 2016 00:00:00 +0800</pubDate>
        <link>/autobuild(3)</link>
        <guid isPermaLink="true">/autobuild(3)</guid>
        
        
        <category>autobuild</category>
        
        <category>svn</category>
        
      </item>
    
      <item>
        <title>分布式服务器设计</title>
        <description>&lt;h2 id=&quot;jone-zhangs-blog----httpwwwcnblogscomccdevp3341234html&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/ccdev/p/3341234.html&quot;&gt;Jone Zhang’s Blog – 高并发服务端分布式系统设计概要&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160121_jone_zhang.jpg&quot; alt=&quot;分布式系统设计图&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由N台机器组合而成，其中Global Master一台，Global Slave一台到多台，两者之间保持强一致性并完全同步，&lt;br /&gt;
可由Global Slave随时顶替Global Master工作，它们被Global Heartbeat（一台）来管理，保证有一个Global Master正常工作；&lt;br /&gt;
Global Heartbeat由于无压力，通常认为其不能挂掉，如果它挂掉了，则必须人工干预才能恢复正常；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;整个系统由多个groups合成，每一个group负责相应业务的数据的存取，它们是数据节点，是真正抗压力的地方，&lt;br /&gt;
每一个group由一个Group Master和一个到多个Group Slave构成，Group Master作为该group的主节点，提供读和写，&lt;br /&gt;
而Group Slave则只提供读服务且保证这些Group Slave节点中，至少有一个和Group Master保持完全同步，&lt;br /&gt;
剩余的Group Slave和Group Master能够达到最终一致，它们之间以“半同步”模式工作保证最终一致性；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的健康状态由Global Master来管理，Global Master向group发送管理信息，并保证有一个Group Master正常工作，&lt;br /&gt;
若Group Master宕机，在该group内通过分布式选举产生新的Group Master顶替原来宕机的机器继续工作，&lt;br /&gt;
但仍然有一小段时间需要中断写服务来切换新的Group Master；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每一个group的底层是实际的存储系统，File system，它们是无状态的，即，由分布式选举产生的Group Master可以在原来的File system上继续工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Client的上端可认为是Web请求，Client在“首次”进行数据读写时，向Global Master查询相应的group信息，并将其缓存，&lt;br /&gt;
后续将直接与相应的group进行通信；为避免大量“首次”查询冲垮Global Master，在Client与Global Master之间增加DNS负载均衡，&lt;br /&gt;
可由Global Slave分担部分查询工作；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当Client已经拥有足够的group信息时，它将直接与group通信进行工作，从而真正的压力和流量由各个group分担，并处理完成需要的工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section&quot;&gt;我的分布式游戏服务器设计&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/imgs/20160121_my_server.jpg&quot; alt=&quot;分布式游戏服务器设计图&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 21 Jan 2016 00:00:00 +0800</pubDate>
        <link>/server</link>
        <guid isPermaLink="true">/server</guid>
        
        
        <category>server</category>
        
        <category>分布式</category>
        
      </item>
    
  </channel>
</rss>
