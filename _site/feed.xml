<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>乌托邦</title>
    <description></description>
    <link>https://xiaobin0860.github.io/</link>
    <atom:link href="https://xiaobin0860.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 09 Aug 2021 13:47:42 +0000</pubDate>
    <lastBuildDate>Mon, 09 Aug 2021 13:47:42 +0000</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>AI数学基础-概率论</title>
        <description>&lt;p&gt;同线性代数一样，概率论也代表了一种看待世界的方式，&lt;code&gt;其关注的焦点是无处不在的可能性&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;频率学派&quot;&gt;频率学派&lt;/h2&gt;

&lt;p&gt;从事件发生的频率认识概率的方法被称为“频率学派”（frequentist probability），“概率”，其实是一个可独立重复的随机实验中单个结果出现频率的极限。在概率的定量计算上，频率学派依赖的基础是古典概率模型。假设所有基本事件的数目为 n，待观察的随机事件 A 中包含的基本事件数目为 k，则古典概率模型下事件概率的计算公式为&lt;/p&gt;

&lt;p&gt;$P(A) = \frac{k}{n}$&lt;/p&gt;

&lt;p&gt;&lt;code&gt;条件概率&lt;/code&gt;是根据已有信息对样本空间进行调整后得到的新的概率分布。假定有两个随机事件 A 和 B，条件概率就是指事件 A 在事件 B 已经发生的条件下发生的概率，用以下公式表示&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A&lt;/td&gt;
      &lt;td&gt;B) = \frac{P(AB)}{P(B)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(AB)$称为&lt;code&gt;联合概率&lt;/code&gt;，表示的是 A 和 B 两个事件共同发生的概率。如果联合概率等于两个事件各自概率的乘积，即$P(AB) = P(A)*P(B)$，说明这两个事件的发生互不影响，即两者相互独立。&lt;/p&gt;

&lt;p&gt;基于条件概率可以得出&lt;code&gt;全概率公式&lt;/code&gt;。全概率公式的作用在于将复杂事件的概率求解转化为在不同情况下发生的简单事件的概率求和，即&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(A) = \sum_{i=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;$\sum_{i=1}^NP(B_i) = 1$&lt;/p&gt;

&lt;p&gt;全概率公式代表了频率学派解决概率问题的思路，即先做出一些假设$P(B_i​)$，再在这些假设下讨论随机事件的概率$P(A∣B_i​)$。&lt;/p&gt;

&lt;h2 id=&quot;贝叶斯学派&quot;&gt;贝叶斯学派&lt;/h2&gt;

&lt;p&gt;对全概率公式稍作整理，就演化出了求解“逆概率”这一重要问题。所谓“逆概率”解决的是在事件结果已经确定的条件下$P(A)$，推断各种假设发生的可能性$P(B_i​∣A)$。其通用的公式形式被称为贝叶斯公式：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(B_i&lt;/td&gt;
      &lt;td&gt;A) = \frac{P(A&lt;/td&gt;
      &lt;td&gt;B_i)*P(B_i)}{\sum_{j=1}^NP(A&lt;/td&gt;
      &lt;td&gt;B_j)*P(B_j)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;贝叶斯公式可以进一步抽象为贝叶斯定理：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;$P(H&lt;/td&gt;
      &lt;td&gt;D) = \frac{P(D&lt;/td&gt;
      &lt;td&gt;H)*P(H)}{P(D)}$&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上式中$P(H)$被称为&lt;code&gt;先验概率&lt;/code&gt;，即预先设定的假设成立的概率；$P(D∣H)$被称为&lt;code&gt;似然概率&lt;/code&gt;，是在假设成立的前提下观测到结果的概率；$P(H∣D)$被称为&lt;code&gt;后验概率&lt;/code&gt;，即在观测到结果的前提下假设成立的概率。&lt;/p&gt;

&lt;p&gt;贝叶斯定理提供了一种全新的逻辑。它根据观测结果寻找合理的假设，或者说根据观测数据寻找最佳的理论解释，其关注的焦点在于后验概率。概率论的&lt;code&gt;贝叶斯学派&lt;/code&gt;正是诞生于这种理念。&lt;/p&gt;

&lt;h2 id=&quot;应用&quot;&gt;应用&lt;/h2&gt;

&lt;p&gt;频率学派认为假设是客观存在且不会改变的，即存在固定的先验分布，只是作为观察者的我们无从知晓。因而在计算具体事件的概率时，要先确定概率分布的类型和参数，以此为基础进行概率推演。相比之下，贝叶斯学派则认为固定的先验分布是不存在的，参数本身也是随机数。换言之，假设本身取决于观察结果，是不确定并且可以修正的。数据的作用就是对假设做出不断的修正，使观察者对概率的主观认识更加接近客观实际。&lt;/p&gt;

&lt;p&gt;概率论是线性代数之外，人工智能的另一个理论基础，多数机器学习模型采用的都是基于概率论的方法。但由于实际任务中可供使用的训练数据有限，因而需要对概率分布的参数进行估计，这也是机器学习的核心任务。&lt;/p&gt;

&lt;p&gt;概率的估计有两种方法：&lt;code&gt;最大似然估计法&lt;/code&gt;和&lt;code&gt;最大后验概率法&lt;/code&gt;，两者分别体现出频率学派和贝叶斯学派对概率的理解方式。最大似然估计法的思想是使训练数据出现的概率最大化，依此确定概率分布中的未知参数，估计出的概率分布也就最符合训练数据的分布。最大后验概率法的思想则是根据训练数据和已知的其他条件，使未知参数出现的可能性最大化，并选取最可能的未知参数取值作为估计值。在估计参数时，最大似然估计法只需要使用训练数据，最大后验概率法除了数据外还需要额外的信息，就是贝叶斯公式中的先验概率。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;概率论关注的是生活中的不确定性或可能性&lt;/li&gt;
  &lt;li&gt;频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算&lt;/li&gt;
  &lt;li&gt;贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Mon, 09 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E6%A6%82%E7%8E%87%E8%AE%BA</guid>
        
        
        <category>AI</category>
        
        <category>概率论</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(2)</title>
        <description>&lt;h2 id=&quot;线性空间&quot;&gt;线性空间&lt;/h2&gt;

&lt;p&gt;一个集合，它的元素是具有相同维数的向量，并且定义了加法和数乘结构化运算，这样的集合就被称为&lt;code&gt;线性空间&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;内积空间&quot;&gt;内积空间&lt;/h2&gt;

&lt;p&gt;定义了内积运算的线性空间被称为&lt;code&gt;内积空间&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;内积空间中，一组两两正交的向量构成这个空间的&lt;code&gt;正交基&lt;/code&gt;，若正交基中基向量的$L^2$范数都是单位长度 1，这组正交基就是&lt;code&gt;标准正交基&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;矩阵&quot;&gt;矩阵&lt;/h2&gt;

&lt;p&gt;线性空间点的变化对应着向量的线性变换，而描述对象变化抑或向量变化的语言，正是矩阵&lt;/p&gt;

&lt;p&gt;线性空间中变化的实现有两种方式：一是点本身的变化，二是参考系的变化。
在第一种方式中，使某个点发生变化的方法是用代表变化的矩阵乘以代表对象的向量。而对坐标系施加变换的方法，就是让表示原始坐标系的矩阵与表示变换的矩阵相乘。&lt;/p&gt;

&lt;p&gt;描述矩阵的一对重要参数是&lt;code&gt;特征值&lt;/code&gt;和&lt;code&gt;特征向量&lt;/code&gt;。对于给定的矩阵$A$，假设其特征值为$\lambda$，特征向量为$\vec x$，则它们的关系如下：&lt;/p&gt;

&lt;p&gt;$A\vec x = \lambda\vec x$&lt;/p&gt;

&lt;p&gt;矩阵代表了向量的变换，其效果通常是对原始向量同时施加方向变化和尺度变化。可对于有些特殊的向量，矩阵的作用只有尺度变化而没有方向变化，也就是只有伸缩的效果而没有旋转的效果。对于给定的矩阵来说，这类特殊的向量就是矩阵的特征向量，特征向量的尺度变化系数就是特征值。&lt;/p&gt;

&lt;p&gt;求解给定矩阵的特征值和特征向量的过程叫做特征值分解，但能够进行特征值分解的矩阵必须是 n 维方阵。将特征值分解算法推广到所有矩阵之上，就是更加通用的奇异值分解。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性&lt;/li&gt;
  &lt;li&gt;向量的实质是 n 维线性空间中静止的点&lt;/li&gt;
  &lt;li&gt;线性变换描述向量或作为参考系的坐标的变化，可以用矩阵表示&lt;/li&gt;
  &lt;li&gt;矩阵的特征值和特征向量描述了变化的速度和方向&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
</description>
        <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A32</guid>
        
        
        <category>AI</category>
        
      </item>
    
      <item>
        <title>AI数学基础-线性代数(1)</title>
        <description>&lt;h2 id=&quot;人工智能理解&quot;&gt;人工智能理解&lt;/h2&gt;

&lt;p&gt;建立在以线性代数和概率论为骨架的基础数学上，通过简单的模型组合实现复杂的功能。&lt;/p&gt;

&lt;h2 id=&quot;线性代数的核心意义&quot;&gt;线性代数的核心意义&lt;/h2&gt;

&lt;p&gt;万事万物都可以被抽象成某些特征的组合，并在由预置规则定义的框架之下以静态和动态的方式加以观察。&lt;/p&gt;

&lt;p&gt;用虚拟数字世界表示真实物理世界的工具。&lt;/p&gt;

&lt;h2 id=&quot;线性代数基本概念&quot;&gt;线性代数基本概念&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;集合(set)：某些特定对象汇总成的集体&lt;/li&gt;
  &lt;li&gt;标量(scalar)：单独数&lt;code&gt;a&lt;/code&gt;构成的元素，&lt;code&gt;a&lt;/code&gt;可以是&lt;code&gt;整数&lt;/code&gt;、&lt;code&gt;实数&lt;/code&gt;或&lt;code&gt;复数&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向量(vector)：多个标量按一定顺序组成一个序列&lt;/p&gt;

    &lt;p&gt;向量可以看作标量的扩展，原始的数被替代为一组数，从而带来了维度的增加，给定表示索引的下标才能唯一确定向量中的元素&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;矩阵(matrix)：交向量的所有标量都替换成同规格的向量&lt;/p&gt;

    &lt;p&gt;相对于向量，矩阵同样代表了维度的增加，矩阵中的每个元素需要两个索引确定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;张量(tensor)：将矩阵中的每个标量再替换为向量，得到的就是张量。张量就是高阶矩阵&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;描述向量的数学语言&quot;&gt;描述向量的数学语言&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;范数(norm)：对单个向量大小的度量，描述的是向量自身的性质，其作用是将向量映射为一个非负的数值。通用$L^p 范数定义如下：&lt;/p&gt;

    &lt;p&gt;$∣\vec x∣_p​ = (\sum_i∣x_i​∣^p)^\frac{1}{p}$​&lt;/p&gt;

    &lt;p&gt;对于一个给定的向量，$L^1$范数计算的是向量所有元素绝对值的和，$L^2$范数计算的是通常意义的向量长度，$L^\infty$范数计算的则是向量中最大元素的取值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内积(inner product)：计算的是两个向量的关系。两个同维向量内积的表达式为&lt;/p&gt;

    &lt;p&gt;$&amp;lt;\vec x, \vec y&amp;gt; = \sum_ix_i*y_i$&lt;/p&gt;

    &lt;p&gt;即对应元素乘积的求和。内积能表示两个向量的相对位置，即向量之间的夹角。一种特殊的情况是内积是 0，即$&amp;lt;\vec x, \vec y&amp;gt; = 0$，在二维空间上，这意味着两个向量夹角 90 度，即相互垂直。而在高维空间上，这咱关系被称为&lt;code&gt;正交(orthogonality)&lt;/code&gt;。如果两个向量正交，说明它们线性无关，相互独立，互不影响。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
</description>
        <pubDate>Sat, 07 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/AI_%E7%BA%BF%E4%BB%A31</guid>
        
        
        <category>AI</category>
        
        <category>线性代数</category>
        
      </item>
    
      <item>
        <title>Git Add</title>
        <description>&lt;p&gt;Add a folder to git with exceptions&lt;/p&gt;

&lt;p&gt;Given this folder structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;app
├── bin
│  └── parse-ansi-codes.rs
├── Cargo.lock
├── Cargo.toml
├── README.md
├── src
│  ├── cursor.rs
│  ├── lib.rs
│  └── style.rs
├── target
│  └── debug
└── test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I can add the entire &lt;code&gt;app&lt;/code&gt; directory to git, while ignoring the bin folder:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git add . ':!bin'
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210805.jpg&quot; alt=&quot;宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/git_add_with_exceptions</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_add_with_exceptions</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>Git Proxy</title>
        <description>&lt;h2 id=&quot;http-代理&quot;&gt;HTTP 代理&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;git config --global http.proxy 127.0.0.1:1080
git config --global https.proxy 127.0.0.1:1080
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;ssh-代理&quot;&gt;SSH 代理&lt;/h2&gt;

&lt;p&gt;SSH 代理需要在密钥目录&lt;code&gt;~/.ssh&lt;/code&gt;(Windows 下是&lt;code&gt;C:\Users\{UserName}\.ssh&lt;/code&gt;)新建一个&lt;code&gt;config&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cat ~/.ssh/config
Host github.com
    ProxyCommand connect -S 127.0.0.1:1080 %h %p
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20210803.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/git_proxy</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/git_proxy</guid>
        
        
        <category>git</category>
        
      </item>
    
      <item>
        <title>VS Code的使用</title>
        <description>&lt;h2 id=&quot;vs-code-快捷键&quot;&gt;VS Code 快捷键&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;光标移动&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;方向键&lt;/code&gt;: 在&lt;strong&gt;单个字符&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + 左右方向键&lt;/code&gt;): 在&lt;strong&gt;单词&lt;/strong&gt;之间移动光标&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 左右方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Home/End&lt;/code&gt;): 把光标移动到行首或者行末&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Option + Shift + \&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Shift + \&lt;/code&gt;): 光标在&lt;strong&gt;代码块&lt;/strong&gt;的始末跳转&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;Cmd + 上下方向键&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl + Home/End&lt;/code&gt;): 光标移动到文档的第一行或者最后一行&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文本选择&lt;/p&gt;

    &lt;p&gt;只需要多按一个 Shift 键，就可以在移动光标的同时选中其中的文本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的一个单词&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Backspace&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之前的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Delete&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除光标之后的整行内容&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + K&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;删除整行(剪切 Cmd+X 也可用于删除整行)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑操作&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Mac 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;Win 快捷键&lt;/th&gt;
          &lt;th style=&quot;text-align: left&quot;&gt;作用&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行下面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Cmd + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Ctrl + Shift + Enter&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;在当前行上面新增一行，然后跳至该行&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下移动&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↑&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向上复制&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Option + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;&lt;code&gt;Alt + Shift + ↓&lt;/code&gt;&lt;/td&gt;
          &lt;td style=&quot;text-align: left&quot;&gt;将代码向下复制&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自定义快捷键&lt;/p&gt;

    &lt;p&gt;&lt;code&gt;Cmd+K, Cmd+S&lt;/code&gt;(Windows 上是&lt;code&gt;Ctrl+K, Ctrl+S&lt;/code&gt;)打开”Keyboard Shortcuts”窗口修改&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Backspace&lt;/code&gt; 删除光标之前的整行内容(Delete All Left)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Delete&lt;/code&gt; 删除光标之后的整行内容(Delete All Right)&lt;/li&gt;
      &lt;li&gt;Win &lt;code&gt;Alt + Shift + ]&lt;/code&gt; 选择括号内所有内容(Select to Bracket)&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + U&lt;/code&gt; Transform to Uppercase&lt;/li&gt;
      &lt;li&gt;All &lt;code&gt;Ctrl + L&lt;/code&gt; Transform to Lowercase&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20191012.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/VSCode</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/VSCode</guid>
        
        
        <category>vscode</category>
        
        <category>editor</category>
        
      </item>
    
      <item>
        <title>用nginx代理phoenix应用</title>
        <description>&lt;h2 id=&quot;upstream-proxy&quot;&gt;&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_upstream_module.html#upstream&quot;&gt;upstream proxy&lt;/a&gt;&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;upstream fvlandingpagebygeo_phoenix {
  server 127.0.0.1:8900
}

server {
  server_name fvlandingpagebygeo.com www.fvlandingpagebygeo.com;

  listen 80 default_server;
  listen [::]:80 default_server;

  root /srv/www/fvlandingpagebygeo.com/htdocs;
  index index.html;

  location / {
    # pass the requests on to our proxy
    try_files $uri @proxy;
  }
  
  location @proxy {
    include proxy_params;
    proxy_redirect off;
    proxy_pass http://fvlandingpagebygeo_phoenix;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;phoenix应用作为子目录&quot;&gt;phoenix应用作为子目录&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;nginx配置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-nginx&quot;&gt;map $http_upgrade $connection_upgrade {
  default upgrade;
  ''      close;
}

location ~ /(phx|phoenix) {
  proxy_pass http://127.0.0.1:4000;
  # Proxy Headers
  proxy_redirect off;
  proxy_http_version 1.1;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $http_host;
  proxy_set_header X-Cluster-Client-Ip $remote_addr;

  # WebSockets
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection $connection_upgrade;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/Xiaobin0860/phx_umbrella/commit/bf348686bdfd19a39e81fb293ab00974e9ee6471&quot;&gt;phx app修改&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;any compiled assets need to be prefixed with the subdirectory&lt;/li&gt;
  &lt;li&gt;any reference to those assets needs to be prefixed with the subdirectory&lt;/li&gt;
  &lt;li&gt;all links should be prefixed with the subdirector&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;http://geoffreylessel.com/2016/hosting-a-phoenix-app-in-a-subdirectory-with-nginx/&quot;&gt;Hosting A Phoenix App In A Subdirectory With Nginx&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20190406.jpg&quot; alt=&quot;宝宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Apr 2019 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/phx_nginx</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/phx_nginx</guid>
        
        
        <category>phoenix</category>
        
        <category>nginx</category>
        
      </item>
    
      <item>
        <title>Vim Format</title>
        <description>&lt;h2 id=&quot;vim-format&quot;&gt;vim format&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;gg 跳转到第一行&lt;/li&gt;
  &lt;li&gt;shift+v 转到可视模式&lt;/li&gt;
  &lt;li&gt;shift+g 全选&lt;/li&gt;
  &lt;li&gt;按下神奇的 =&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20180528.png&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 28 May 2018 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/vim_format</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/vim_format</guid>
        
        
        <category>vim</category>
        
      </item>
    
      <item>
        <title>Elixir Application Supervisor</title>
        <description>&lt;h2 id=&quot;application-behaviour&quot;&gt;&lt;code&gt;Application&lt;/code&gt; behaviour&lt;/h2&gt;

&lt;p&gt;In Elixir (actually, in Erlang/OTP), an application is a component implementing some specific functionality, that can be started and stopped as a unit, and which can be re-used in other systems.&lt;/p&gt;

&lt;h3 id=&quot;start-and-shutdown&quot;&gt;Start and shutdown&lt;/h3&gt;

&lt;p&gt;Starting an application is done via the “application module callback”, which is a module that defines the &lt;code&gt;start/2&lt;/code&gt; function. The &lt;code&gt;start/2&lt;/code&gt; function should then start a supervisor, which is often called as the top-level supervisor, since it sits at the root of a potentially long supervision tree. When the system is shutting down, all applications shut down their top-level supervisor, which terminates children in the opposite order they are started.&lt;/p&gt;

&lt;h3 id=&quot;application-module-callback&quot;&gt;Application module callback&lt;/h3&gt;

&lt;p&gt;The first step is to pass the module callback in the application definition in the mix.exs file:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;def application do
  [mod: {MyApp, []}]
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our application now requires the &lt;code&gt;MyApp&lt;/code&gt; module to provide an application callback. This can be done by invoking &lt;code&gt;use Application&lt;/code&gt; in that module and defining a &lt;code&gt;start/2&lt;/code&gt; callback, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;defmodule MyApp do
  use Application

  def start(_type, _args) do
    children = []
    Supervisor.start_link(children, strategy: :one_for_one)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;start/2&lt;/code&gt; typically returns &lt;code&gt;{:ok, pid}&lt;/code&gt; or &lt;code&gt;{:ok, pid, state}&lt;/code&gt; where &lt;code&gt;pid&lt;/code&gt; identifies the supervision tree and &lt;code&gt;state&lt;/code&gt; is the application state. &lt;code&gt;args&lt;/code&gt; is the second element of the tuple given to the &lt;code&gt;:mod&lt;/code&gt; option.&lt;/p&gt;

&lt;p&gt;When an application is shutting down, its &lt;code&gt;stop/1&lt;/code&gt; callback is called after the supervision tree has been stopped by the runtime. This callback allows the application to do any final cleanup. The argument is the state returned by &lt;code&gt;start/2&lt;/code&gt;, if it did, or &lt;code&gt;[]&lt;/code&gt; otherwise. The return value of &lt;code&gt;stop/1&lt;/code&gt; is ignored.&lt;/p&gt;

&lt;h2 id=&quot;supervisor-behaviour&quot;&gt;&lt;code&gt;Supervisor&lt;/code&gt; behaviour&lt;/h2&gt;

&lt;p&gt;A supervisor is a process which supervises other processes, which we refer to as &lt;code&gt;child processes&lt;/code&gt;. Supervisors are used to build a hierarchical process structure called a &lt;code&gt;supervision tree&lt;/code&gt;. Supervision trees provide fault-tolerance and encapsulate how our applications start and shutdown.&lt;/p&gt;

&lt;p&gt;A supervisor may be started directly with a list of children via &lt;code&gt;start_link/2&lt;/code&gt; or you may define a module-based supervisor that implements the required callbacks.&lt;/p&gt;

&lt;h3 id=&quot;examples&quot;&gt;Examples&lt;/h3&gt;

&lt;p&gt;As an example, we will define a GenServer that represents a stack. The stack is a small wrapper around lists. It allows us to put an element on the top of the stack, by prepending to the list, and to get the top of the stack by pattern matching.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;defmodule Stack do
  use GenServer

  def start_link(state) do
    GenServer.start_link(__MODULE__, state, name: __MODULE__)
  end

  ## Callbacks

  @impl true
  def init(stack) do
    {:ok, stack}
  end

  @impl true
  def handle_call(:pop, _from, [h | t]) do
    {:reply, h, t}
  end

  @impl true
  def handle_cast({:push, h}, t) do
    {:noreply, [h | t]}
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now start a supervisor that will start and supervise our stack process. The first step is to define a list of &lt;code&gt;child specifications&lt;/code&gt; that control how each child behaves. Each child specification is a map, as shown below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;children = [
  # The Stack is a child started via Stack.start_link([:hello])
  %{
    id: Stack,
    start: {Stack, :start_link, [[:hello]]}
  }
]

# Now we start the supervisor with the children and a strategy
{:ok, pid} = Supervisor.start_link(children, strategy: :one_for_one)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that when starting the GenServer, we are registering it with name Stack, which allows us to call it directly and get what is on the stack:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;GenServer.call(Stack, :pop)
#=&amp;gt; :hello
GenServer.cast(Stack, {:push, :world})
#=&amp;gt; :ok
GenServer.call(Stack, :pop)
#=&amp;gt; :world
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;child-specification&quot;&gt;Child specification&lt;/h3&gt;

&lt;p&gt;The child specification describes how the supervisor start, shutdown and restart child processes.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;:id&lt;/code&gt; - a value used to identify the child specification internally by the supervisor; defaults to the given module. In case of conflicting &lt;code&gt;:id&lt;/code&gt;, the supervisor will refuse to initialize and require explicit IDs. This key is required.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;:start&lt;/code&gt; - a tuple with the module-function-args to be invoked to start the child process. This key is required.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;:restart&lt;/code&gt; - an atom that defines when a terminated child process should be restarted (see the “Restart values” section below). This key is optional and defaults to &lt;code&gt;:permanent&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;:shutdown&lt;/code&gt; - an atom that defines how a child process should be terminated (see the “Shutdown values” section below). This key is optional and defaults to 5000 if the type is &lt;code&gt;:worker&lt;/code&gt; or &lt;code&gt;:infinity&lt;/code&gt; if the type is &lt;code&gt;:supervisor&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;:type&lt;/code&gt; - if the child process is a &lt;code&gt;:worker&lt;/code&gt; or a &lt;code&gt;:supervisor&lt;/code&gt;. This key is optional and defaults to &lt;code&gt;:worker&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There is a sixth key, called &lt;code&gt;:modules&lt;/code&gt;, which is rarely changed and it is set automatically based on the value in &lt;code&gt;:start&lt;/code&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20180525.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/elixir_app_sup</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/elixir_app_sup</guid>
        
        
        <category>elixir</category>
        
      </item>
    
      <item>
        <title>理解计算机系统(1)</title>
        <description>&lt;h2 id=&quot;编译四个阶段&quot;&gt;编译四个阶段&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;预处理阶段
&lt;code&gt;#include&lt;/code&gt;告诉预处理器将指定文件内容插入到本文件中&lt;/li&gt;
  &lt;li&gt;编译阶段
生成汇编文件&lt;/li&gt;
  &lt;li&gt;汇编阶段
汇编文件 =&amp;gt; 可重定位目标程序(.o)&lt;/li&gt;
  &lt;li&gt;链接阶段
.o =&amp;gt; 可执行文件&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;硬件组成&quot;&gt;硬件组成&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;总线
传送定长字节块 =&amp;gt; 字(word)&lt;/li&gt;
  &lt;li&gt;I/O设备&lt;/li&gt;
  &lt;li&gt;主存&lt;/li&gt;
  &lt;li&gt;CPU&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;操作系统&quot;&gt;操作系统&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;文件(字节序列)，是对I/O设备的抽象&lt;/li&gt;
  &lt;li&gt;虚拟内存是对主存和磁盘的抽象&lt;/li&gt;
  &lt;li&gt;进程是对CPU、主存和I/O设备的抽象&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://xiaobin0860.github.io/imgs/20180513.jpg&quot; alt=&quot;大宝&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 13 May 2018 00:00:00 +0000</pubDate>
        <link>https://xiaobin0860.github.io/computer_systems</link>
        <guid isPermaLink="true">https://xiaobin0860.github.io/computer_systems</guid>
        
        
        <category>system</category>
        
      </item>
    
  </channel>
</rss>
